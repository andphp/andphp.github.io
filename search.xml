<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Docker-Rancher在K8S上部署高性能PHP应用程序</title>
      <link href="2020/11/16/%E4%BD%BF%E7%94%A8Docker-Rancher%E5%9C%A8K8S%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%AB%98%E6%80%A7%E8%83%BDPHP%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>2020/11/16/%E4%BD%BF%E7%94%A8Docker-Rancher%E5%9C%A8K8S%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%AB%98%E6%80%A7%E8%83%BDPHP%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="介-绍"><a href="#介-绍" class="headerlink" title="介 绍"></a>介 绍</h3><blockquote><p>PHP是网络上最流行的编程语言之一，许多被广泛使用的内容管理系统都使用它开发，如WordPress和Drupal，并为现代服务器端框架（如Laravel和Symfony）提供核心代码。</p></blockquote><blockquote><p>尽管PHP很受欢迎，但是其缓慢和难以维护也是众所周知的。近几年这两个毛病已经没有那么严重了，但是高性能的PHP应用程序依然会需要两个功能：OPcache和PHP FastCGI进程管理器（PHP-FPM）。</p></blockquote><blockquote><p>在本文中，你将了解到在Kubernetes上如何使用自定义OPcache和PHP-FPM配置部署一个PHP应用程序以提高其性能。你将使用Rancher来部署一个PHP应用程序，该应用程序使用自定义环境变量来动态配置OPcache和PHP-FPM。我们将展示如何在你的Docker镜像中构建PHP-FPM配置选项并在容器中使用环境变量调整它们。</p></blockquote><h3 id="在PHP中的性能"><a href="#在PHP中的性能" class="headerlink" title="在PHP中的性能"></a>在PHP中的性能</h3><blockquote><p>首先，了解PHP应用程序中如何处理网络请求将对本文接下来的内容很有帮助。</p></blockquote><blockquote><p>PHP通常运行在web服务器旁边，处理请求并将它们发送到PHP应用程序中。你可以使用PHP-FPM或mod_PHP来运行你的应用程序，但在本文中我们将使用PHP-FPM，因为其性能优势并且NGINX是最常与PHP-FPM一起使用的web服务器。</p></blockquote><h3 id="OPcache介绍"><a href="#OPcache介绍" class="headerlink" title="OPcache介绍"></a>OPcache介绍</h3><p>OPcache通过在首次调用脚本时将脚本存储在内存中来加速PHP应用程序。进而，随后的请求将从内存而不是文件系统加载，这可以使你的速度提高74%。</p><p>OPcache提供了一些设置，你可以调整这些设置来提高应用程序的性能和可靠性。在本篇教程中，你将了解到如何设置一个PHP Docker镜像，该镜像可以调整OPcache的内存限制、缓存文件数量以及重新验证缓存频率。</p><h3 id="PHP-FPM介绍"><a href="#PHP-FPM介绍" class="headerlink" title="PHP-FPM介绍"></a>PHP-FPM介绍</h3><p>PHP-FPM（FastCGI进程管理器）会启动一个或多个进程以运行你的PHP应用程序。与mod_PHP（将PHP捆绑为Apache模块）不同，PHP-FPM使你可以精确控制服务器（或容器）运行的进程数量，以及它们应该如何启动和停止。</p><p>找到一个理想的PHP-FPM配置高度依赖于你的应用程序以及它所服务的请求数量和容器中的内存和CPU限制。我推荐你阅读Hayden James关于这个主题的文章（链接已放在文末）并且在负载测试环境下测试几种不同的配置。</p><h3 id="在K8S上部署一个PHP应用程序"><a href="#在K8S上部署一个PHP应用程序" class="headerlink" title="在K8S上部署一个PHP应用程序"></a>在K8S上部署一个PHP应用程序</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><p>在你进行本篇教程之前，你需要做好以下准备：</p><p>在你本地机器上安装好的Docker</p><p>Docker Hub或其他Docker镜像仓库上的账号</p><p>Rancher部署（如果你还没部署，可以按照Quick start进行）</p><p>通过Rancher管理的Kubernetes集群</p><p>在本教程中使用的所有代码都可以在Github中获取，或者你可以按照以下步骤从头开始构建应用程序。</p><h4 id="PHP应用程序"><a href="#PHP应用程序" class="headerlink" title="PHP应用程序"></a>PHP应用程序</h4><p>你将要使用的应用程序是一个显示当前日期的PHP文件。创建一个新文件并将其命名为index.php：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &#39;The current date is &#39; . date(&#39;F jS, Y&#39;);</span><br></pre></td></tr></table></figure><h4 id="创建Dockerfile和配置文件"><a href="#创建Dockerfile和配置文件" class="headerlink" title="创建Dockerfile和配置文件"></a>创建Dockerfile和配置文件</h4><p>在Docker Hub上，你可以获得很多PHP Docker镜像，但它们都没有提供使用环境变量来修改OPcache或PHP-FPM配置的简便方法。使用环境变量的优势在于，您无需每次要调整PHP-FPM或OPcache设置时都需要重建PHP映像。这可以让你快速调整你的应用程序以提升性能。</p><p>首先，创建一个名为opcache.ini的新文件。你将复制该文件到PHP镜像中并在Dockerfile中为每个环境变量添加默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># See https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;en&#x2F;opcache.configuration.php for all available configuration options.</span><br><span class="line">[opcache]</span><br><span class="line">opcache.enable&#x3D;$&#123;PHP_OPCACHE_ENABLE&#125;</span><br><span class="line">opcache.memory_consumption&#x3D;$&#123;PHP_OPCACHE_MEMORY_CONSUMPTION&#125;</span><br><span class="line">opcache.max_accelerated_files&#x3D;$&#123;PHP_OPCACHE_MAX_ACCELERATED_FILES&#125;</span><br><span class="line">opcache.revalidate_freq&#x3D;$&#123;PHP_OPCACHE_REVALIDATE_FREQUENCY&#125;</span><br><span class="line">opcache.validate_timestamps&#x3D;$&#123;PHP_OPCACHE_VALIDATE_TIMESTAMPS&#125;</span><br></pre></td></tr></table></figure><p>接下来，创建另一个名为<a href="http://www.conf的新文件。该文件将存储PHP-FPM配置选项，你可以通过环境变量对其进行更新：">www.conf的新文件。该文件将存储PHP-FPM配置选项，你可以通过环境变量对其进行更新：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; See https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;en&#x2F;install.fpm.configuration.php for all available configuration options</span><br><span class="line"></span><br><span class="line">; Required user, group, and port options</span><br><span class="line">[www]</span><br><span class="line">user &#x3D; www-data</span><br><span class="line">group &#x3D; www-data</span><br><span class="line">listen &#x3D; 127.0.0.1:9000</span><br><span class="line"></span><br><span class="line">; Process manager options</span><br><span class="line">pm &#x3D; $&#123;PHP_FPM_PM&#125;</span><br><span class="line">pm.max_children &#x3D; $&#123;PHP_FPM_MAX_CHILDREN&#125;</span><br><span class="line">pm.start_servers &#x3D; $&#123;PHP_FPM_START_SERVERS&#125;</span><br><span class="line">pm.min_spare_servers &#x3D; $&#123;PHP_FPM_MIN_SPARE_SERVERS&#125;</span><br><span class="line">pm.max_spare_servers &#x3D; $&#123;PHP_FPM_MAX_SPARE_SERVERS&#125;</span><br><span class="line">pm.max_requests &#x3D; $&#123;PHP_FPM_MAX_REQUESTS&#125;</span><br></pre></td></tr></table></figure><p>你需要复制这些文件到你的Docker镜像中并且设置默认的环境变量值，因此请在项目的根目录中创建一个新的Dockerfile。添加以下步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FROM php:7.4-fpm</span><br><span class="line"></span><br><span class="line"># OPcache defaults</span><br><span class="line">ENV PHP_OPCACHE_ENABLE&#x3D;&quot;1&quot;</span><br><span class="line">ENV PHP_OPCACHE_MEMORY_CONSUMPTION&#x3D;&quot;128&quot;</span><br><span class="line">ENV PHP_OPCACHE_MAX_ACCELERATED_FILES&#x3D;&quot;10000&quot;</span><br><span class="line">ENV PHP_OPCACHE_REVALIDATE_FREQUENCY&#x3D;&quot;0&quot;</span><br><span class="line">ENV PHP_OPCACHE_VALIDATE_TIMESTAMPS&#x3D;&quot;0&quot;</span><br><span class="line"></span><br><span class="line"># Install opcache and add the configuration file</span><br><span class="line">RUN docker-php-ext-install opcache</span><br><span class="line">ADD opcache.ini &quot;$PHP_INI_DIR&#x2F;conf.d&#x2F;opcache.ini&quot;</span><br><span class="line"></span><br><span class="line"># PHP-FPM defaults</span><br><span class="line">ENV PHP_FPM_PM&#x3D;&quot;dynamic&quot;</span><br><span class="line">ENV PHP_FPM_MAX_CHILDREN&#x3D;&quot;5&quot;</span><br><span class="line">ENV PHP_FPM_START_SERVERS&#x3D;&quot;2&quot;</span><br><span class="line">ENV PHP_FPM_MIN_SPARE_SERVERS&#x3D;&quot;1&quot;</span><br><span class="line">ENV PHP_FPM_MAX_SPARE_SERVERS&#x3D;&quot;2&quot;</span><br><span class="line">ENV PHP_FPM_MAX_REQUESTS&#x3D;&quot;1000&quot;</span><br><span class="line"></span><br><span class="line"># Copy the PHP-FPM configuration file</span><br><span class="line">COPY .&#x2F;www.conf &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf</span><br><span class="line"></span><br><span class="line"># Copy the PHP application file</span><br><span class="line">COPY .&#x2F;index.php &#x2F;var&#x2F;www&#x2F;public&#x2F;index.php</span><br><span class="line">RUN chown -R www-data:www-data &#x2F;var&#x2F;www&#x2F;public</span><br></pre></td></tr></table></figure><p>Dockerfile将OPCache配置、PHP-FPM配置以及PHP应用程序文件复制到镜像中，并确保包含PHP代码的var/www/public目录为PHP-FPM用户所有。ENV 声明设置了默认的PHP_OPCACHE_…和PHP_FPM_…环境变量，但你可以在运行这个镜像时随时覆盖它们。这将使实际部署中的性能调整变得更加容易。</p><h4 id="构建并推送到DockerHub"><a href="#构建并推送到DockerHub" class="headerlink" title="构建并推送到DockerHub"></a>构建并推送到DockerHub</h4><p>至此，你的项目中已经有了一个单文件PHP应用程序、一个OPcache配置文件、一个PHP-FPM配置文件和一个Dockerfile。你现在可以构建你的Docker镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;YOUR_USERNAME&gt;&#x2F;php-fpm .</span><br></pre></td></tr></table></figure><p>接下来，将镜像推送到Docker Hub：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push &lt;YOUR_USERNAME&gt;&#x2F;php-fpm</span><br></pre></td></tr></table></figure><h4 id="部署一个PHP-FPM工作负载"><a href="#部署一个PHP-FPM工作负载" class="headerlink" title="部署一个PHP-FPM工作负载"></a>部署一个PHP-FPM工作负载</h4><p>既然你的自定义PHP-FPM镜像在Docker Hub上已经可以获取，你可以将其作为工作负载的一部分部署在Kubernetes集群上。使用Rancher UI，创建一个新的deployment，将其命名为php-fpm，并使用<YOUR_USERNAME>/php-fpm作为Docker镜像。你可以修改以上Dockerfile中使用的任何PHP_OPCACHE _…和PHP_FPM _…环境变量。</p><p>在设置Nginx工作负载以服务于PHP-FPM deployment之前，请检查你的PHP-FPM和OPcache设置是否已正确添加到容器中。在Rancher UI中，单击PHP deployment旁边的三个点，然后单击“ Execute Shell”：</p><p>要检查OPcache模块是否已启用，请键入php-fpm -i。这将输出整个PHP .ini配置。浏览一下OPcache上的部分，你应该会看到类似以下内容（更改的任何值都会反映出来）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">opcache.blacklist_filename &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.consistency_checks &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.dups_fix &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.enable &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">opcache.enable_cli &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.enable_file_override &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.error_log &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.file_cache &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.file_cache_consistency_checks &#x3D;&gt; 1 &#x3D;&gt; 1</span><br><span class="line">opcache.file_cache_only &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.file_update_protection &#x3D;&gt; 2 &#x3D;&gt; 2</span><br><span class="line">opcache.force_restart_timeout &#x3D;&gt; 180 &#x3D;&gt; 180</span><br><span class="line">opcache.huge_code_pages &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.interned_strings_buffer &#x3D;&gt; 8 &#x3D;&gt; 8</span><br><span class="line">opcache.lockfile_path &#x3D;&gt; &#x2F;tmp &#x3D;&gt; &#x2F;tmp</span><br><span class="line">opcache.log_verbosity_level &#x3D;&gt; 1 &#x3D;&gt; 1</span><br><span class="line">opcache.max_accelerated_files &#x3D;&gt; 10000 &#x3D;&gt; 10000</span><br><span class="line">opcache.max_file_size &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.max_wasted_percentage &#x3D;&gt; 5 &#x3D;&gt; 5</span><br><span class="line">opcache.memory_consumption &#x3D;&gt; 256 &#x3D;&gt; 256</span><br><span class="line">opcache.opt_debug_level &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.optimization_level &#x3D;&gt; 0x7FFEBFFF &#x3D;&gt; 0x7FFEBFFF</span><br><span class="line">opcache.preferred_memory_model &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.preload &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.preload_user &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.protect_memory &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.restrict_api &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.revalidate_freq &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.revalidate_path &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.save_comments &#x3D;&gt; 1 &#x3D;&gt; 1</span><br><span class="line">opcache.use_cwd &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">opcache.validate_permission &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.validate_root &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.validate_timestamps &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>每当你重新部署PHP-FPM工作负载时，PHP-FPM都会重新启动并重置OPcache，因此，当你在Kubernetes上运行PHP-FPM时，你通常不必担心重置OPcache。如果确实要手动刷新缓存，最简单的方法是从Rancher UI重新部署工作负载。</p><p>为了确保PHP-FPM配置更改可以生效，请在shell中键入php-fpm -tt。你应该看到所有PHP-FPM选项的列表，包括进程管理器更新的部分（该管理器添加到<a href="http://www.conf文件并使用环境变量进行设置）：">www.conf文件并使用环境变量进行设置）：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NOTICE:  pm &#x3D; dynamic</span><br><span class="line">NOTICE:  pm.max_children &#x3D; 10</span><br><span class="line">NOTICE:  pm.start_servers &#x3D; 2</span><br><span class="line">NOTICE:  pm.min_spare_servers &#x3D; 1</span><br><span class="line">NOTICE:  pm.max_spare_servers &#x3D; 2</span><br><span class="line">NOTICE:  pm.process_idle_timeout &#x3D; 10</span><br><span class="line">NOTICE:  pm.max_requests &#x3D; 1000</span><br></pre></td></tr></table></figure><h4 id="部署Nginx工作负载"><a href="#部署Nginx工作负载" class="headerlink" title="部署Nginx工作负载"></a>部署Nginx工作负载</h4><p>现在，你有一个PHP-FPM工作负载，但是没有Web服务器可以访问它。你可以使用许多NGINX Docker镜像来为你的PHP应用程序提供服务，但是我通常使用这个NGINX镜像（<a href="https://www.shiphp.com/blog/2018/nginx-php-fpm-with-env">https://www.shiphp.com/blog/2018/nginx-php-fpm-with-env</a> ），它允许你通过使用环境变量将一个镜像用于任意数量的PHP-FPM工作负载。</p><p>在Rancher UI中创建新的工作负载，该负载与PHP-FPM工作负载在相同的集群上。将其命名为nginx，使用Docker镜像shiphp / nginx-env，将容器上的端口80映射到集群上的开放端口，并添加环境变量NGINX_HOST = php-fpm：</p><p>如果你把PHP-FPM工作负载命名为php-fpm以外的名字，或者你想为第二个工作负载提供服务，你可以使用NGINX_HOST环境变量来连接它，这也允许你在同一个集群上运行多个PHP-FPM和Nginx工作负载。这也允许你在同一个集群上运行多个PHP-FPM和Nginx工作负载。</p><p>一旦你的Nginx工作负载可用，点击它所在的端口链接，打开Web应用程序。你应该看到你的PHP脚本生成的当前日期。</p><h3 id="结-论"><a href="#结-论" class="headerlink" title="结 论"></a>结 论</h3><p>现在，你已经将PHP-FPM工作负载部署到了Kubernetes集群中，你可以开始真正的性能调优工作了。幸运的是，现在更新 PHP-FPM 和 OPcache设置就像更改环境变量和重新部署 Workload 一样简单。这将允许你尝试新的设置，并比重新构建镜像更快获得反馈。</p><p>从Web应用程序中获得最佳性能是一个反复的过程，但希望本教程中的Kubernetes部署能帮助你构建更高性能的PHP应用程序。</p><blockquote><p>参考链接：</p></blockquote><blockquote><p>PHP性能提升：<br><a href="https://gbksoft.com/blog/php-5-vs-php-7-performance-comparison/">https://gbksoft.com/blog/php-5-vs-php-7-performance-comparison/</a></p></blockquote><blockquote><p>PHP-FPM性能优势：<br><a href="https://www.cloudways.com/blog/php-fpm-on-cloud/">https://www.cloudways.com/blog/php-fpm-on-cloud/</a></p></blockquote><blockquote><p>NGINX<br><a href="http://nginx.org/en/">http://nginx.org/en/</a></p></blockquote><blockquote><p>Pcache配置设置：<br><a href="https://www.php.net/manual/en/opcache.configuration.php">https://www.php.net/manual/en/opcache.configuration.php</a></p></blockquote><blockquote><p>提升性能以及你的OPcache应用程序可靠性：<br><a href="https://tideways.com/profiler/blog/fine-tune-your-opcache-configuration-to-avoid-caching-suprises">https://tideways.com/profiler/blog/fine-tune-your-opcache-configuration-to-avoid-caching-suprises</a></p></blockquote><blockquote><p>Hayden James的PHP-FPM调整文章：<br><a href="https://haydenjames.io/php-fpm-tuning-using-pm-static-max-performance/">https://haydenjames.io/php-fpm-tuning-using-pm-static-max-performance/</a></p></blockquote><blockquote><p>PHP-FPM配置测试：<br><a href="https://speakerdeck.com/erictendian/performance-testing-and-optimization-with-laravel-and-lumen">https://speakerdeck.com/erictendian/performance-testing-and-optimization-with-laravel-and-lumen</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
          <category> Rancher </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker-rancher搭建k8s集群环境</title>
      <link href="2020/11/15/Docker-rancher%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83/"/>
      <url>2020/11/15/Docker-rancher%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>新建rancher目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --privileged --restart&#x3D;unless-stopped -p 8080:80 -p 8443:443 -v &#x2F;home&#x2F;daxiong&#x2F;rancher:&#x2F;var&#x2F;lib&#x2F;rancher&#x2F; --name rancher rancher&#x2F;rancher:stable</span><br></pre></td></tr></table></figure><p><a href="https://git.wyz.ltd/">https://git.wyz.ltd/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab-runner  gitlab-runner register</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><blockquote><p>mysql:5.7</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;mysql&#x2F;conf.d:conf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;mysql:data</span><br></pre></td></tr></table></figure><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><blockquote><p>redis:5-alpine</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;conf:n1&#x2F;conf</span><br><span class="line">&#x2F;data:n1&#x2F;data</span><br><span class="line">&#x2F;logs:n1&#x2F;logs</span><br></pre></td></tr></table></figure><blockquote><p>redis-server /conf/redis.conf</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建用户赋Docker权限</title>
      <link href="2020/11/13/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%B5%8BDocker%E6%9D%83%E9%99%90/"/>
      <url>2020/11/13/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%B5%8BDocker%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><ol><li>增加用户 useradd [username]</li><li>设置用户密码 passwd [username]</li><li>删除用户 userdel [username]</li><li>查看所有用户 cat /etc/passwd</li><li>查看当前活跃用户 w</li><li>查看简明用户列表 cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F”:” ‘{ print $1”|”$3”|”$4 }’|more</li></ol><h3 id="用户组操作"><a href="#用户组操作" class="headerlink" title="用户组操作"></a>用户组操作</h3><ol><li>新建工作组 groupadd [groupname]</li><li>将用户添加进工作组 usermod -G [groupname] [username]</li><li>查看用户组 cat /etc/group</li></ol><h3 id="授权sudo权限，需要修改sudoers文件。"><a href="#授权sudo权限，需要修改sudoers文件。" class="headerlink" title="授权sudo权限，需要修改sudoers文件。"></a>授权sudo权限，需要修改sudoers文件。</h3><blockquote><p>首先找到文件位置，示例中文件在/etc/sudoers位置。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis sudoers</span><br></pre></td></tr></table></figure><blockquote><p>强调内容 修改文件权限，一般文件默认为只读。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;etc&#x2F;sudoers 查看文件权限</span><br><span class="line">chmod -v u+w &#x2F;etc&#x2F;sudoers 修改文件权限为可编辑</span><br></pre></td></tr></table></figure><blockquote><p>修改文件，在如下位置增加一行，保存退出。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sudoers 进入文件编辑器</span><br></pre></td></tr></table></figure><ul><li>文件内容改变如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root ALL&#x3D;(ALL) ALL 已有行</span><br><span class="line">username ALL&#x3D;(ALL) ALL 新增行</span><br></pre></td></tr></table></figure><blockquote><p>记得将文件权限还原回只读。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;etc&#x2F;sudoers 查看文件权限</span><br><span class="line">chmod -v u-w &#x2F;etc&#x2F;sudoers 修改文件权限为只读</span><br></pre></td></tr></table></figure></li></ul><h3 id="docker-权限"><a href="#docker-权限" class="headerlink" title="docker 权限"></a>docker 权限</h3><blockquote><p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker     #添加docker用户组</span><br><span class="line">sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中</span><br><span class="line">newgrp docker     #更新用户组</span><br><span class="line">docker ps    #测试docker命令是否可以使用sudo正常使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-CentOS7-升级内核的方法</title>
      <link href="2020/11/13/Linux-CentOS7-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>2020/11/13/Linux-CentOS7-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="查看操作系统内核版本"><a href="#查看操作系统内核版本" class="headerlink" title="查看操作系统内核版本"></a>查看操作系统内核版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h3 id="安装ELRepo到CentOS"><a href="#安装ELRepo到CentOS" class="headerlink" title="安装ELRepo到CentOS"></a>安装ELRepo到CentOS</h3><blockquote><p>最好从官方网站获取最新版本（官网地址：<a href="http://elrepo.org/tiki/tiki-index.php%EF%BC%89%EF%BC%8C%E4%B8%8B%E9%9D%A2%E4%B8%A4%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9B%B4%E6%8E%A5%E4%BB%8E%E5%AE%98%E7%BD%91%E4%B8%8A%E5%A4%8D%E5%88%B6%E6%9C%80%E6%96%B0%E7%89%88%E7%9A%84%E5%8D%B3%E5%8F%AF%E3%80%82">http://elrepo.org/tiki/tiki-index.php），下面两个命令直接从官网上复制最新版的即可。</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;www.elrepo.org&#x2F;RPM-GPG-KEY-elrepo.org</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-7.0-3.el7.elrepo.noarch.rpm -y</span><br></pre></td></tr></table></figure><h3 id="添加-repository-后-列出可以使用的kernel包版本"><a href="#添加-repository-后-列出可以使用的kernel包版本" class="headerlink" title="添加 repository 后, 列出可以使用的kernel包版本"></a>添加 repository 后, 列出可以使用的kernel包版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo&#x3D;&quot;*&quot; --enablerepo&#x3D;&quot;elrepo-kernel&quot; list available</span><br></pre></td></tr></table></figure><h3 id="安装需要的kernel版本，这里安装-kernel-lt"><a href="#安装需要的kernel版本，这里安装-kernel-lt" class="headerlink" title="安装需要的kernel版本，这里安装 kernel-lt"></a>安装需要的kernel版本，这里安装 kernel-lt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo&#x3D;elrepo-kernel install kernel-lt -y</span><br></pre></td></tr></table></figure><blockquote><p>内核版本介绍：<br>lt:longterm的缩写：长期维护版；<br>ml:mainline的缩写：最新稳定版；</p></blockquote><h3 id="检查kernel启动顺序"><a href="#检查kernel启动顺序" class="headerlink" title="检查kernel启动顺序"></a>检查kernel启动顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;boot&#x2F;grub2&#x2F;grub.cfg</span><br></pre></td></tr></table></figure><blockquote><p>查看到刚才安装的kernel版本处在第一个位置，修改/etc/default/grub文件是系统在运行时自动执行最新的kernel</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;default&#x2F;grub</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DEFAULT&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="重新创建kernel配置"><a href="#重新创建kernel配置" class="headerlink" title="重新创建kernel配置"></a>重新创建kernel配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg</span><br></pre></td></tr></table></figure><h3 id="重新启动服务器使用最新kernel"><a href="#重新启动服务器使用最新kernel" class="headerlink" title="重新启动服务器使用最新kernel"></a>重新启动服务器使用最新kernel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS环境配置安装Docker</title>
      <link href="2020/11/13/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85Docker/"/>
      <url>2020/11/13/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85Docker/</url>
      
        <content type="html"><![CDATA[<h3 id="CentOS环境配置安装Docker"><a href="#CentOS环境配置安装Docker" class="headerlink" title="CentOS环境配置安装Docker"></a>CentOS环境配置安装Docker</h3><h4 id="查看升级系统内核"><a href="#查看升级系统内核" class="headerlink" title="查看升级系统内核"></a>查看升级系统内核</h4><blockquote><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p></blockquote><ul><li>通过 uname -r 命令查看你当前的内核版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h4 id="使用-root-权限登录-Centos。确保-yum-包更新到最新。"><a href="#使用-root-权限登录-Centos。确保-yum-包更新到最新。" class="headerlink" title="使用 root 权限登录 Centos。确保 yum 包更新到最新。"></a>使用 root 权限登录 Centos。确保 yum 包更新到最新。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure><h4 id="卸载旧版本-如果安装过旧版本的话"><a href="#卸载旧版本-如果安装过旧版本的话" class="headerlink" title="卸载旧版本(如果安装过旧版本的话)"></a>卸载旧版本(如果安装过旧版本的话)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><h4 id="安装需要的软件包"><a href="#安装需要的软件包" class="headerlink" title="安装需要的软件包"></a>安装需要的软件包</h4><blockquote><p>yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="设置yum源"><a href="#设置yum源" class="headerlink" title="设置yum源"></a>设置yum源</h4><blockquote><p>设置yum源【docker官方镜像源】</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><blockquote><p>设置yum源【docker阿里镜像源】</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><blockquote><p>可以查看所有仓库中所有docker版本，并选择特定版本安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;7&#x2F;x86_64&#x2F;stable&#x2F;Packages&#x2F;containerd.io-1.2.6-3.3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><blockquote><p>由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install &lt;FQPN&gt;  # 例如：sudo yum install docker-ce-17.12.0.ce</span><br></pre></td></tr></table></figure><blockquote><p>安装docker</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce -y</span><br></pre></td></tr></table></figure><h4 id="启动并加入开机启动"><a href="#启动并加入开机启动" class="headerlink" title="启动并加入开机启动"></a>启动并加入开机启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><blockquote><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>因为之前已经安装过旧版本的docker，在安装的时候报错如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transaction check error:</span><br><span class="line">  file &#x2F;usr&#x2F;bin&#x2F;docker from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;bin&#x2F;docker-containerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;bin&#x2F;docker-containerd-shim from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;bin&#x2F;dockerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br></pre></td></tr></table></figure><blockquote><p>卸载旧版本的包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum erase docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br></pre></td></tr></table></figure><blockquote><p>再次安装docker</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><blockquote><p>安装epel源.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><blockquote><p>安装docker-compose</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-compose</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP从入门到放弃</title>
      <link href="2020/11/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%20PHP%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
      <url>2020/11/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%20PHP%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
      
        <content type="html"><![CDATA[<h3 id="PHP3是世界的语言"><a href="#PHP3是世界的语言" class="headerlink" title="PHP3是世界的语言"></a>PHP3是世界的语言</h3><h4 id="PHP是世界上最好的语言"><a href="#PHP是世界上最好的语言" class="headerlink" title="PHP是世界上最好的语言"></a>PHP是世界上最好的语言</h4><h5 id="PHP5是世界上最好的语言"><a href="#PHP5是世界上最好的语言" class="headerlink" title="PHP5是世界上最好的语言"></a>PHP5是世界上最好的语言</h5><h6 id="PHP6是世界上最好的语言"><a href="#PHP6是世界上最好的语言" class="headerlink" title="PHP6是世界上最好的语言"></a>PHP6是世界上最好的语言</h6><ul><li><p>出处</p><p>”php是世界上最好的语言“这句话，最早出现在2001年7月的PHP文档中。</p><p>而在这之后不久，我们就可以看到更激进的言论了，Because PHP is the best language ever, ever. It’s fast, very powerful, and free.因为PHP是有史以来最好的语言，没有之一。它快速，非常强大，而且免费。</p></li></ul><p>当然php本身确实足够优秀。</p><p><img src="/img/post/2020-11-13/php.jpg"></p><ul><li><p>争论</p><p>争论于是乎在网络的各个地方，语言好坏之争炒出了新高度，再安静的论坛，只要一句”php是世界上最好的语言“就能吵半天的。</p></li><li><p>讲个段子</p><p>某女：你能让这个论坛的人都吵起来，我今晚就跟你走。</p><p>某软件工程师：PHP是最好的语言！</p><p>某论坛真的就炸锅了，各种吵架……</p><p>某女：服了你了，我们走吧，你想干啥都行。</p><p>某软件工程师：今天不行，我一定要说服他们，PHP必须是最好的语言…</p></li><li><p>总结</p><p>这是个情怀的问题，但是不止是情怀的问题；从这个角度来回答，那么任何东西只要能够满足你情怀就是最好的，所以如果php能够支撑起你的梦想，用php能够解决你工作当中遇到的问题，让你能够生活下去，那么它就是最好的语言。</p><p>但是语言只是一个解决问题的工具，不能仅局限于使用某种语言，拥抱开放，才能看的更远，多掌握一种工具，在面对问题的时候就会多一种解决方案，人生永远不要给自己设限。</p><p>php历经多年依然很棒，在web开发领域，依然被广泛使用，也将被长期使用，至少目前没有后来者居上的情况发生。但对每个phper来说，立足当下，着眼未来才是关键，不要固步自封，学会开放的胸怀去面对，走出自己的舒适区，再学至少一门编程语言吧。只有在学习中我们才能进步，这一点其实php本身就在慢慢的改变，只要你有心去注意，你会发现，你所用的几个流行的php开发框架越来越多的在借鉴java的开发思想。php本身都在不断的学习进步，作为一个phper，我们有什么理由原地踏步呢？</p></li></ul><h3 id="PHP3是世界的语言-1"><a href="#PHP3是世界的语言-1" class="headerlink" title="PHP3是世界的语言"></a>PHP3是世界的语言</h3><hr><h4 id="给传统PHP插上翅膀的现代PHP扩展-SWOOLE"><a href="#给传统PHP插上翅膀的现代PHP扩展-SWOOLE" class="headerlink" title="给传统PHP插上翅膀的现代PHP扩展 SWOOLE"></a>给传统PHP插上翅膀的现代PHP扩展 SWOOLE</h4><p><img src="/img/post/2020-11-13/swoole.jpg"></p><ul><li><p>Swore : 让PHP无所不能</p><p>Swoole 使 PHP 开发人员可以编写高性能高并发的 TCP、UDP、Unix Socket、HTTP、 WebSocket 等服务，让 PHP 不再局限于 Web 领域。Swoole4 协程的成熟将 PHP 带入了前所未有的时期， 为性能的提升提供了独一无二的可能性。Swoole 可以广泛应用于互联网、移动通信、云计算、 网络游戏、物联网（IOT）、车联网、智能家居等领域。使用 PHP + Swoole 可以使企业 IT 研发团队的效率大大提升，更加专注于开发创新产品。</p></li></ul><hr><h4 id="如何从PHP过渡到Go-golang"><a href="#如何从PHP过渡到Go-golang" class="headerlink" title="如何从PHP过渡到Go(golang)"></a>如何从PHP过渡到Go(golang)</h4><ul><li><p>Go语言的前世今生</p><p>Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。</p><p>2012年正式发布。</p></li><li><p>Go语言的特性和优势</p><p>go是21世纪的C语言，也是云计算时代的C语言，它的诞生是为了有更高的开发效率。</p><p><strong>go的最大优势就是执行速度和开发效率都很出色，而且从语言级别上支持并发。执行速度快是因为go是编译型的静态语言，它在执行速度上比解释型语言具有先天的优势。生产效率高是基于go的语法和结构简明，易学易用。</strong></p></li></ul><p><img src="/img/post/2020-11-13/golang.jpg"></p><hr><h3 id="博客内容分享既定技术方向和目标"><a href="#博客内容分享既定技术方向和目标" class="headerlink" title="博客内容分享既定技术方向和目标"></a>博客内容分享既定技术方向和目标</h3><ol><li>主要 围绕 PHP和GOLANG 语言在 web 应用中涉及到的 环境搭建 、技术选型及案例分析 展开博客日志记录分享。</li><li>包括但不限于 对 时下 web应用 周边语言、应用或框架、动态新闻 进行跟踪学习分享</li></ol><ul><li><p>Git</p><p>是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 [1] Git 是 [Linus Torvalds] 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p></li><li><p>Docker</p><p>Docker是一个开放源代码软件项目，让应用程序部署在软件货柜下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。</p></li><li><p>Vue.js</p><p>Vue.js是一套构建用户界面的渐进式框架，Vue 采用自下向上增量开发的设计，其核心库只关注视图层，易于上手，同时vue完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> GOLANG </tag>
            
            <tag> ANDPHP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
