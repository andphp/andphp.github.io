<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Docker-Rancher在K8S上部署高性能PHP应用程序</title>
      <link href="2020/11/16/%E4%BD%BF%E7%94%A8Docker-Rancher%E5%9C%A8K8S%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%AB%98%E6%80%A7%E8%83%BDPHP%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>2020/11/16/%E4%BD%BF%E7%94%A8Docker-Rancher%E5%9C%A8K8S%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%AB%98%E6%80%A7%E8%83%BDPHP%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="介-绍"><a href="#介-绍" class="headerlink" title="介 绍"></a>介 绍</h3><blockquote><p>PHP是网络上最流行的编程语言之一，许多被广泛使用的内容管理系统都使用它开发，如WordPress和Drupal，并为现代服务器端框架（如Laravel和Symfony）提供核心代码。</p></blockquote><blockquote><p>尽管PHP很受欢迎，但是其缓慢和难以维护也是众所周知的。近几年这两个毛病已经没有那么严重了，但是高性能的PHP应用程序依然会需要两个功能：OPcache和PHP FastCGI进程管理器（PHP-FPM）。</p></blockquote><blockquote><p>在本文中，你将了解到在Kubernetes上如何使用自定义OPcache和PHP-FPM配置部署一个PHP应用程序以提高其性能。你将使用Rancher来部署一个PHP应用程序，该应用程序使用自定义环境变量来动态配置OPcache和PHP-FPM。我们将展示如何在你的Docker镜像中构建PHP-FPM配置选项并在容器中使用环境变量调整它们。</p></blockquote><h3 id="在PHP中的性能"><a href="#在PHP中的性能" class="headerlink" title="在PHP中的性能"></a>在PHP中的性能</h3><blockquote><p>首先，了解PHP应用程序中如何处理网络请求将对本文接下来的内容很有帮助。</p></blockquote><blockquote><p>PHP通常运行在web服务器旁边，处理请求并将它们发送到PHP应用程序中。你可以使用PHP-FPM或mod_PHP来运行你的应用程序，但在本文中我们将使用PHP-FPM，因为其性能优势并且NGINX是最常与PHP-FPM一起使用的web服务器。</p></blockquote><h3 id="OPcache介绍"><a href="#OPcache介绍" class="headerlink" title="OPcache介绍"></a>OPcache介绍</h3><p>OPcache通过在首次调用脚本时将脚本存储在内存中来加速PHP应用程序。进而，随后的请求将从内存而不是文件系统加载，这可以使你的速度提高74%。</p><p>OPcache提供了一些设置，你可以调整这些设置来提高应用程序的性能和可靠性。在本篇教程中，你将了解到如何设置一个PHP Docker镜像，该镜像可以调整OPcache的内存限制、缓存文件数量以及重新验证缓存频率。</p><h3 id="PHP-FPM介绍"><a href="#PHP-FPM介绍" class="headerlink" title="PHP-FPM介绍"></a>PHP-FPM介绍</h3><p>PHP-FPM（FastCGI进程管理器）会启动一个或多个进程以运行你的PHP应用程序。与mod_PHP（将PHP捆绑为Apache模块）不同，PHP-FPM使你可以精确控制服务器（或容器）运行的进程数量，以及它们应该如何启动和停止。</p><p>找到一个理想的PHP-FPM配置高度依赖于你的应用程序以及它所服务的请求数量和容器中的内存和CPU限制。我推荐你阅读Hayden James关于这个主题的文章（链接已放在文末）并且在负载测试环境下测试几种不同的配置。</p><h3 id="在K8S上部署一个PHP应用程序"><a href="#在K8S上部署一个PHP应用程序" class="headerlink" title="在K8S上部署一个PHP应用程序"></a>在K8S上部署一个PHP应用程序</h3><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><p>在你进行本篇教程之前，你需要做好以下准备：</p><p>在你本地机器上安装好的Docker</p><p>Docker Hub或其他Docker镜像仓库上的账号</p><p>Rancher部署（如果你还没部署，可以按照Quick start进行）</p><p>通过Rancher管理的Kubernetes集群</p><p>在本教程中使用的所有代码都可以在Github中获取，或者你可以按照以下步骤从头开始构建应用程序。</p><h4 id="PHP应用程序"><a href="#PHP应用程序" class="headerlink" title="PHP应用程序"></a>PHP应用程序</h4><p>你将要使用的应用程序是一个显示当前日期的PHP文件。创建一个新文件并将其命名为index.php：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &#39;The current date is &#39; . date(&#39;F jS, Y&#39;);</span><br></pre></td></tr></table></figure><h4 id="创建Dockerfile和配置文件"><a href="#创建Dockerfile和配置文件" class="headerlink" title="创建Dockerfile和配置文件"></a>创建Dockerfile和配置文件</h4><p>在Docker Hub上，你可以获得很多PHP Docker镜像，但它们都没有提供使用环境变量来修改OPcache或PHP-FPM配置的简便方法。使用环境变量的优势在于，您无需每次要调整PHP-FPM或OPcache设置时都需要重建PHP映像。这可以让你快速调整你的应用程序以提升性能。</p><p>首先，创建一个名为opcache.ini的新文件。你将复制该文件到PHP镜像中并在Dockerfile中为每个环境变量添加默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># See https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;en&#x2F;opcache.configuration.php for all available configuration options.</span><br><span class="line">[opcache]</span><br><span class="line">opcache.enable&#x3D;$&#123;PHP_OPCACHE_ENABLE&#125;</span><br><span class="line">opcache.memory_consumption&#x3D;$&#123;PHP_OPCACHE_MEMORY_CONSUMPTION&#125;</span><br><span class="line">opcache.max_accelerated_files&#x3D;$&#123;PHP_OPCACHE_MAX_ACCELERATED_FILES&#125;</span><br><span class="line">opcache.revalidate_freq&#x3D;$&#123;PHP_OPCACHE_REVALIDATE_FREQUENCY&#125;</span><br><span class="line">opcache.validate_timestamps&#x3D;$&#123;PHP_OPCACHE_VALIDATE_TIMESTAMPS&#125;</span><br></pre></td></tr></table></figure><p>接下来，创建另一个名为<a href="http://www.conf的新文件。该文件将存储PHP-FPM配置选项，你可以通过环境变量对其进行更新：">www.conf的新文件。该文件将存储PHP-FPM配置选项，你可以通过环境变量对其进行更新：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; See https:&#x2F;&#x2F;www.php.net&#x2F;manual&#x2F;en&#x2F;install.fpm.configuration.php for all available configuration options</span><br><span class="line"></span><br><span class="line">; Required user, group, and port options</span><br><span class="line">[www]</span><br><span class="line">user &#x3D; www-data</span><br><span class="line">group &#x3D; www-data</span><br><span class="line">listen &#x3D; 127.0.0.1:9000</span><br><span class="line"></span><br><span class="line">; Process manager options</span><br><span class="line">pm &#x3D; $&#123;PHP_FPM_PM&#125;</span><br><span class="line">pm.max_children &#x3D; $&#123;PHP_FPM_MAX_CHILDREN&#125;</span><br><span class="line">pm.start_servers &#x3D; $&#123;PHP_FPM_START_SERVERS&#125;</span><br><span class="line">pm.min_spare_servers &#x3D; $&#123;PHP_FPM_MIN_SPARE_SERVERS&#125;</span><br><span class="line">pm.max_spare_servers &#x3D; $&#123;PHP_FPM_MAX_SPARE_SERVERS&#125;</span><br><span class="line">pm.max_requests &#x3D; $&#123;PHP_FPM_MAX_REQUESTS&#125;</span><br></pre></td></tr></table></figure><p>你需要复制这些文件到你的Docker镜像中并且设置默认的环境变量值，因此请在项目的根目录中创建一个新的Dockerfile。添加以下步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FROM php:7.4-fpm</span><br><span class="line"></span><br><span class="line"># OPcache defaults</span><br><span class="line">ENV PHP_OPCACHE_ENABLE&#x3D;&quot;1&quot;</span><br><span class="line">ENV PHP_OPCACHE_MEMORY_CONSUMPTION&#x3D;&quot;128&quot;</span><br><span class="line">ENV PHP_OPCACHE_MAX_ACCELERATED_FILES&#x3D;&quot;10000&quot;</span><br><span class="line">ENV PHP_OPCACHE_REVALIDATE_FREQUENCY&#x3D;&quot;0&quot;</span><br><span class="line">ENV PHP_OPCACHE_VALIDATE_TIMESTAMPS&#x3D;&quot;0&quot;</span><br><span class="line"></span><br><span class="line"># Install opcache and add the configuration file</span><br><span class="line">RUN docker-php-ext-install opcache</span><br><span class="line">ADD opcache.ini &quot;$PHP_INI_DIR&#x2F;conf.d&#x2F;opcache.ini&quot;</span><br><span class="line"></span><br><span class="line"># PHP-FPM defaults</span><br><span class="line">ENV PHP_FPM_PM&#x3D;&quot;dynamic&quot;</span><br><span class="line">ENV PHP_FPM_MAX_CHILDREN&#x3D;&quot;5&quot;</span><br><span class="line">ENV PHP_FPM_START_SERVERS&#x3D;&quot;2&quot;</span><br><span class="line">ENV PHP_FPM_MIN_SPARE_SERVERS&#x3D;&quot;1&quot;</span><br><span class="line">ENV PHP_FPM_MAX_SPARE_SERVERS&#x3D;&quot;2&quot;</span><br><span class="line">ENV PHP_FPM_MAX_REQUESTS&#x3D;&quot;1000&quot;</span><br><span class="line"></span><br><span class="line"># Copy the PHP-FPM configuration file</span><br><span class="line">COPY .&#x2F;www.conf &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf</span><br><span class="line"></span><br><span class="line"># Copy the PHP application file</span><br><span class="line">COPY .&#x2F;index.php &#x2F;var&#x2F;www&#x2F;public&#x2F;index.php</span><br><span class="line">RUN chown -R www-data:www-data &#x2F;var&#x2F;www&#x2F;public</span><br></pre></td></tr></table></figure><p>Dockerfile将OPCache配置、PHP-FPM配置以及PHP应用程序文件复制到镜像中，并确保包含PHP代码的var/www/public目录为PHP-FPM用户所有。ENV 声明设置了默认的PHP_OPCACHE_…和PHP_FPM_…环境变量，但你可以在运行这个镜像时随时覆盖它们。这将使实际部署中的性能调整变得更加容易。</p><h4 id="构建并推送到DockerHub"><a href="#构建并推送到DockerHub" class="headerlink" title="构建并推送到DockerHub"></a>构建并推送到DockerHub</h4><p>至此，你的项目中已经有了一个单文件PHP应用程序、一个OPcache配置文件、一个PHP-FPM配置文件和一个Dockerfile。你现在可以构建你的Docker镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;YOUR_USERNAME&gt;&#x2F;php-fpm .</span><br></pre></td></tr></table></figure><p>接下来，将镜像推送到Docker Hub：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push &lt;YOUR_USERNAME&gt;&#x2F;php-fpm</span><br></pre></td></tr></table></figure><h4 id="部署一个PHP-FPM工作负载"><a href="#部署一个PHP-FPM工作负载" class="headerlink" title="部署一个PHP-FPM工作负载"></a>部署一个PHP-FPM工作负载</h4><p>既然你的自定义PHP-FPM镜像在Docker Hub上已经可以获取，你可以将其作为工作负载的一部分部署在Kubernetes集群上。使用Rancher UI，创建一个新的deployment，将其命名为php-fpm，并使用<YOUR_USERNAME>/php-fpm作为Docker镜像。你可以修改以上Dockerfile中使用的任何PHP_OPCACHE _…和PHP_FPM _…环境变量。</p><p>在设置Nginx工作负载以服务于PHP-FPM deployment之前，请检查你的PHP-FPM和OPcache设置是否已正确添加到容器中。在Rancher UI中，单击PHP deployment旁边的三个点，然后单击“ Execute Shell”：</p><p>要检查OPcache模块是否已启用，请键入php-fpm -i。这将输出整个PHP .ini配置。浏览一下OPcache上的部分，你应该会看到类似以下内容（更改的任何值都会反映出来）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">opcache.blacklist_filename &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.consistency_checks &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.dups_fix &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.enable &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">opcache.enable_cli &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.enable_file_override &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.error_log &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.file_cache &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.file_cache_consistency_checks &#x3D;&gt; 1 &#x3D;&gt; 1</span><br><span class="line">opcache.file_cache_only &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.file_update_protection &#x3D;&gt; 2 &#x3D;&gt; 2</span><br><span class="line">opcache.force_restart_timeout &#x3D;&gt; 180 &#x3D;&gt; 180</span><br><span class="line">opcache.huge_code_pages &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.interned_strings_buffer &#x3D;&gt; 8 &#x3D;&gt; 8</span><br><span class="line">opcache.lockfile_path &#x3D;&gt; &#x2F;tmp &#x3D;&gt; &#x2F;tmp</span><br><span class="line">opcache.log_verbosity_level &#x3D;&gt; 1 &#x3D;&gt; 1</span><br><span class="line">opcache.max_accelerated_files &#x3D;&gt; 10000 &#x3D;&gt; 10000</span><br><span class="line">opcache.max_file_size &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.max_wasted_percentage &#x3D;&gt; 5 &#x3D;&gt; 5</span><br><span class="line">opcache.memory_consumption &#x3D;&gt; 256 &#x3D;&gt; 256</span><br><span class="line">opcache.opt_debug_level &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.optimization_level &#x3D;&gt; 0x7FFEBFFF &#x3D;&gt; 0x7FFEBFFF</span><br><span class="line">opcache.preferred_memory_model &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.preload &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.preload_user &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.protect_memory &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.restrict_api &#x3D;&gt; no value &#x3D;&gt; no value</span><br><span class="line">opcache.revalidate_freq &#x3D;&gt; 0 &#x3D;&gt; 0</span><br><span class="line">opcache.revalidate_path &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.save_comments &#x3D;&gt; 1 &#x3D;&gt; 1</span><br><span class="line">opcache.use_cwd &#x3D;&gt; On &#x3D;&gt; On</span><br><span class="line">opcache.validate_permission &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.validate_root &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">opcache.validate_timestamps &#x3D;&gt; Off &#x3D;&gt; Off</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>每当你重新部署PHP-FPM工作负载时，PHP-FPM都会重新启动并重置OPcache，因此，当你在Kubernetes上运行PHP-FPM时，你通常不必担心重置OPcache。如果确实要手动刷新缓存，最简单的方法是从Rancher UI重新部署工作负载。</p><p>为了确保PHP-FPM配置更改可以生效，请在shell中键入php-fpm -tt。你应该看到所有PHP-FPM选项的列表，包括进程管理器更新的部分（该管理器添加到<a href="http://www.conf文件并使用环境变量进行设置）：">www.conf文件并使用环境变量进行设置）：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NOTICE:  pm &#x3D; dynamic</span><br><span class="line">NOTICE:  pm.max_children &#x3D; 10</span><br><span class="line">NOTICE:  pm.start_servers &#x3D; 2</span><br><span class="line">NOTICE:  pm.min_spare_servers &#x3D; 1</span><br><span class="line">NOTICE:  pm.max_spare_servers &#x3D; 2</span><br><span class="line">NOTICE:  pm.process_idle_timeout &#x3D; 10</span><br><span class="line">NOTICE:  pm.max_requests &#x3D; 1000</span><br></pre></td></tr></table></figure><h4 id="部署Nginx工作负载"><a href="#部署Nginx工作负载" class="headerlink" title="部署Nginx工作负载"></a>部署Nginx工作负载</h4><p>现在，你有一个PHP-FPM工作负载，但是没有Web服务器可以访问它。你可以使用许多NGINX Docker镜像来为你的PHP应用程序提供服务，但是我通常使用这个NGINX镜像（<a href="https://www.shiphp.com/blog/2018/nginx-php-fpm-with-env">https://www.shiphp.com/blog/2018/nginx-php-fpm-with-env</a> ），它允许你通过使用环境变量将一个镜像用于任意数量的PHP-FPM工作负载。</p><p>在Rancher UI中创建新的工作负载，该负载与PHP-FPM工作负载在相同的集群上。将其命名为nginx，使用Docker镜像shiphp / nginx-env，将容器上的端口80映射到集群上的开放端口，并添加环境变量NGINX_HOST = php-fpm：</p><p>如果你把PHP-FPM工作负载命名为php-fpm以外的名字，或者你想为第二个工作负载提供服务，你可以使用NGINX_HOST环境变量来连接它，这也允许你在同一个集群上运行多个PHP-FPM和Nginx工作负载。这也允许你在同一个集群上运行多个PHP-FPM和Nginx工作负载。</p><p>一旦你的Nginx工作负载可用，点击它所在的端口链接，打开Web应用程序。你应该看到你的PHP脚本生成的当前日期。</p><h3 id="结-论"><a href="#结-论" class="headerlink" title="结 论"></a>结 论</h3><p>现在，你已经将PHP-FPM工作负载部署到了Kubernetes集群中，你可以开始真正的性能调优工作了。幸运的是，现在更新 PHP-FPM 和 OPcache设置就像更改环境变量和重新部署 Workload 一样简单。这将允许你尝试新的设置，并比重新构建镜像更快获得反馈。</p><p>从Web应用程序中获得最佳性能是一个反复的过程，但希望本教程中的Kubernetes部署能帮助你构建更高性能的PHP应用程序。</p><blockquote><p>参考链接：</p></blockquote><blockquote><p>PHP性能提升：<br><a href="https://gbksoft.com/blog/php-5-vs-php-7-performance-comparison/">https://gbksoft.com/blog/php-5-vs-php-7-performance-comparison/</a></p></blockquote><blockquote><p>PHP-FPM性能优势：<br><a href="https://www.cloudways.com/blog/php-fpm-on-cloud/">https://www.cloudways.com/blog/php-fpm-on-cloud/</a></p></blockquote><blockquote><p>NGINX<br><a href="http://nginx.org/en/">http://nginx.org/en/</a></p></blockquote><blockquote><p>Pcache配置设置：<br><a href="https://www.php.net/manual/en/opcache.configuration.php">https://www.php.net/manual/en/opcache.configuration.php</a></p></blockquote><blockquote><p>提升性能以及你的OPcache应用程序可靠性：<br><a href="https://tideways.com/profiler/blog/fine-tune-your-opcache-configuration-to-avoid-caching-suprises">https://tideways.com/profiler/blog/fine-tune-your-opcache-configuration-to-avoid-caching-suprises</a></p></blockquote><blockquote><p>Hayden James的PHP-FPM调整文章：<br><a href="https://haydenjames.io/php-fpm-tuning-using-pm-static-max-performance/">https://haydenjames.io/php-fpm-tuning-using-pm-static-max-performance/</a></p></blockquote><blockquote><p>PHP-FPM配置测试：<br><a href="https://speakerdeck.com/erictendian/performance-testing-and-optimization-with-laravel-and-lumen">https://speakerdeck.com/erictendian/performance-testing-and-optimization-with-laravel-and-lumen</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
          <category> Rancher </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker-rancher搭建k8s集群环境</title>
      <link href="2020/11/15/Docker-rancher%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83/"/>
      <url>2020/11/15/Docker-rancher%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>新建rancher目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --privileged --restart&#x3D;unless-stopped -p 8080:80 -p 8443:443 -v &#x2F;home&#x2F;daxiong&#x2F;rancher:&#x2F;var&#x2F;lib&#x2F;rancher&#x2F; --name rancher rancher&#x2F;rancher:stable</span><br></pre></td></tr></table></figure><p><a href="https://git.wyz.ltd/">https://git.wyz.ltd/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it gitlab-runner  gitlab-runner register</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><blockquote><p>mysql:5.7</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;mysql&#x2F;conf.d:conf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;mysql:data</span><br></pre></td></tr></table></figure><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><blockquote><p>redis:5-alpine</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;conf:n1&#x2F;conf</span><br><span class="line">&#x2F;data:n1&#x2F;data</span><br><span class="line">&#x2F;logs:n1&#x2F;logs</span><br></pre></td></tr></table></figure><blockquote><p>redis-server /conf/redis.conf</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建用户赋Docker权限</title>
      <link href="2020/11/13/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%B5%8BDocker%E6%9D%83%E9%99%90/"/>
      <url>2020/11/13/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%B5%8BDocker%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h3 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h3><ol><li>增加用户 useradd [username]</li><li>设置用户密码 passwd [username]</li><li>删除用户 userdel [username]</li><li>查看所有用户 cat /etc/passwd</li><li>查看当前活跃用户 w</li><li>查看简明用户列表 cat /etc/passwd|grep -v nologin|grep -v halt|grep -v shutdown|awk -F”:” ‘{ print $1”|”$3”|”$4 }’|more</li></ol><h3 id="用户组操作"><a href="#用户组操作" class="headerlink" title="用户组操作"></a>用户组操作</h3><ol><li>新建工作组 groupadd [groupname]</li><li>将用户添加进工作组 usermod -G [groupname] [username]</li><li>查看用户组 cat /etc/group</li></ol><h3 id="授权sudo权限，需要修改sudoers文件。"><a href="#授权sudo权限，需要修改sudoers文件。" class="headerlink" title="授权sudo权限，需要修改sudoers文件。"></a>授权sudo权限，需要修改sudoers文件。</h3><blockquote><p>首先找到文件位置，示例中文件在/etc/sudoers位置。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis sudoers</span><br></pre></td></tr></table></figure><blockquote><p>强调内容 修改文件权限，一般文件默认为只读。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;etc&#x2F;sudoers 查看文件权限</span><br><span class="line">chmod -v u+w &#x2F;etc&#x2F;sudoers 修改文件权限为可编辑</span><br></pre></td></tr></table></figure><blockquote><p>修改文件，在如下位置增加一行，保存退出。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sudoers 进入文件编辑器</span><br></pre></td></tr></table></figure><ul><li>文件内容改变如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root ALL&#x3D;(ALL) ALL 已有行</span><br><span class="line">username ALL&#x3D;(ALL) ALL 新增行</span><br></pre></td></tr></table></figure><blockquote><p>记得将文件权限还原回只读。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;etc&#x2F;sudoers 查看文件权限</span><br><span class="line">chmod -v u-w &#x2F;etc&#x2F;sudoers 修改文件权限为只读</span><br></pre></td></tr></table></figure></li></ul><h3 id="docker-权限"><a href="#docker-权限" class="headerlink" title="docker 权限"></a>docker 权限</h3><blockquote><p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker     #添加docker用户组</span><br><span class="line">sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中</span><br><span class="line">newgrp docker     #更新用户组</span><br><span class="line">docker ps    #测试docker命令是否可以使用sudo正常使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-CentOS7-升级内核的方法</title>
      <link href="2020/11/13/Linux-CentOS7-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>2020/11/13/Linux-CentOS7-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="查看操作系统内核版本"><a href="#查看操作系统内核版本" class="headerlink" title="查看操作系统内核版本"></a>查看操作系统内核版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h3 id="安装ELRepo到CentOS"><a href="#安装ELRepo到CentOS" class="headerlink" title="安装ELRepo到CentOS"></a>安装ELRepo到CentOS</h3><blockquote><p>最好从官方网站获取最新版本（官网地址：<a href="http://elrepo.org/tiki/tiki-index.php%EF%BC%89%EF%BC%8C%E4%B8%8B%E9%9D%A2%E4%B8%A4%E4%B8%AA%E5%91%BD%E4%BB%A4%E7%9B%B4%E6%8E%A5%E4%BB%8E%E5%AE%98%E7%BD%91%E4%B8%8A%E5%A4%8D%E5%88%B6%E6%9C%80%E6%96%B0%E7%89%88%E7%9A%84%E5%8D%B3%E5%8F%AF%E3%80%82">http://elrepo.org/tiki/tiki-index.php），下面两个命令直接从官网上复制最新版的即可。</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;www.elrepo.org&#x2F;RPM-GPG-KEY-elrepo.org</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https:&#x2F;&#x2F;www.elrepo.org&#x2F;elrepo-release-7.0-3.el7.elrepo.noarch.rpm -y</span><br></pre></td></tr></table></figure><h3 id="添加-repository-后-列出可以使用的kernel包版本"><a href="#添加-repository-后-列出可以使用的kernel包版本" class="headerlink" title="添加 repository 后, 列出可以使用的kernel包版本"></a>添加 repository 后, 列出可以使用的kernel包版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo&#x3D;&quot;*&quot; --enablerepo&#x3D;&quot;elrepo-kernel&quot; list available</span><br></pre></td></tr></table></figure><h3 id="安装需要的kernel版本，这里安装-kernel-lt"><a href="#安装需要的kernel版本，这里安装-kernel-lt" class="headerlink" title="安装需要的kernel版本，这里安装 kernel-lt"></a>安装需要的kernel版本，这里安装 kernel-lt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo&#x3D;elrepo-kernel install kernel-lt -y</span><br></pre></td></tr></table></figure><blockquote><p>内核版本介绍：<br>lt:longterm的缩写：长期维护版；<br>ml:mainline的缩写：最新稳定版；</p></blockquote><h3 id="检查kernel启动顺序"><a href="#检查kernel启动顺序" class="headerlink" title="检查kernel启动顺序"></a>检查kernel启动顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;boot&#x2F;grub2&#x2F;grub.cfg</span><br></pre></td></tr></table></figure><blockquote><p>查看到刚才安装的kernel版本处在第一个位置，修改/etc/default/grub文件是系统在运行时自动执行最新的kernel</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;default&#x2F;grub</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_DEFAULT&#x3D;0</span><br></pre></td></tr></table></figure><h3 id="重新创建kernel配置"><a href="#重新创建kernel配置" class="headerlink" title="重新创建kernel配置"></a>重新创建kernel配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg</span><br></pre></td></tr></table></figure><h3 id="重新启动服务器使用最新kernel"><a href="#重新启动服务器使用最新kernel" class="headerlink" title="重新启动服务器使用最新kernel"></a>重新启动服务器使用最新kernel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS环境配置安装Docker</title>
      <link href="2020/11/13/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85Docker/"/>
      <url>2020/11/13/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85Docker/</url>
      
        <content type="html"><![CDATA[<h3 id="CentOS环境配置安装Docker"><a href="#CentOS环境配置安装Docker" class="headerlink" title="CentOS环境配置安装Docker"></a>CentOS环境配置安装Docker</h3><h4 id="查看升级系统内核"><a href="#查看升级系统内核" class="headerlink" title="查看升级系统内核"></a>查看升级系统内核</h4><blockquote><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</p></blockquote><ul><li>通过 uname -r 命令查看你当前的内核版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><h4 id="使用-root-权限登录-Centos。确保-yum-包更新到最新。"><a href="#使用-root-权限登录-Centos。确保-yum-包更新到最新。" class="headerlink" title="使用 root 权限登录 Centos。确保 yum 包更新到最新。"></a>使用 root 权限登录 Centos。确保 yum 包更新到最新。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure><h4 id="卸载旧版本-如果安装过旧版本的话"><a href="#卸载旧版本-如果安装过旧版本的话" class="headerlink" title="卸载旧版本(如果安装过旧版本的话)"></a>卸载旧版本(如果安装过旧版本的话)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><h4 id="安装需要的软件包"><a href="#安装需要的软件包" class="headerlink" title="安装需要的软件包"></a>安装需要的软件包</h4><blockquote><p>yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h4 id="设置yum源"><a href="#设置yum源" class="headerlink" title="设置yum源"></a>设置yum源</h4><blockquote><p>设置yum源【docker官方镜像源】</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><blockquote><p>设置yum源【docker阿里镜像源】</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><blockquote><p>可以查看所有仓库中所有docker版本，并选择特定版本安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;7&#x2F;x86_64&#x2F;stable&#x2F;Packages&#x2F;containerd.io-1.2.6-3.3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><blockquote><p>由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install &lt;FQPN&gt;  # 例如：sudo yum install docker-ce-17.12.0.ce</span><br></pre></td></tr></table></figure><blockquote><p>安装docker</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce -y</span><br></pre></td></tr></table></figure><h4 id="启动并加入开机启动"><a href="#启动并加入开机启动" class="headerlink" title="启动并加入开机启动"></a>启动并加入开机启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><blockquote><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>因为之前已经安装过旧版本的docker，在安装的时候报错如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Transaction check error:</span><br><span class="line">  file &#x2F;usr&#x2F;bin&#x2F;docker from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;bin&#x2F;docker-containerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;bin&#x2F;docker-containerd-shim from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;bin&#x2F;dockerd from install of docker-ce-17.12.0.ce-1.el7.centos.x86_64 conflicts with file from package docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br></pre></td></tr></table></figure><blockquote><p>卸载旧版本的包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum erase docker-common-2:1.12.6-68.gitec8512b.el7.centos.x86_64</span><br></pre></td></tr></table></figure><blockquote><p>再次安装docker</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><blockquote><p>安装epel源.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><blockquote><p>安装docker-compose</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-compose</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP从入门到放弃</title>
      <link href="2020/11/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%20PHP%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
      <url>2020/11/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%20PHP%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
      
        <content type="html"><![CDATA[<h3 id="PHP3是世界的语言"><a href="#PHP3是世界的语言" class="headerlink" title="PHP3是世界的语言"></a>PHP3是世界的语言</h3><h4 id="PHP是世界上最好的语言"><a href="#PHP是世界上最好的语言" class="headerlink" title="PHP是世界上最好的语言"></a>PHP是世界上最好的语言</h4><h5 id="PHP5是世界上最好的语言"><a href="#PHP5是世界上最好的语言" class="headerlink" title="PHP5是世界上最好的语言"></a>PHP5是世界上最好的语言</h5><h6 id="PHP6是世界上最好的语言"><a href="#PHP6是世界上最好的语言" class="headerlink" title="PHP6是世界上最好的语言"></a>PHP6是世界上最好的语言</h6><ul><li><p>出处</p><p>”php是世界上最好的语言“这句话，最早出现在2001年7月的PHP文档中。</p><p>而在这之后不久，我们就可以看到更激进的言论了，Because PHP is the best language ever, ever. It’s fast, very powerful, and free.因为PHP是有史以来最好的语言，没有之一。它快速，非常强大，而且免费。</p></li></ul><p>当然php本身确实足够优秀。</p><p><img src="/img/post/2020-11-13/php.jpg"></p><ul><li><p>争论</p><p>争论于是乎在网络的各个地方，语言好坏之争炒出了新高度，再安静的论坛，只要一句”php是世界上最好的语言“就能吵半天的。</p></li><li><p>讲个段子</p><p>某女：你能让这个论坛的人都吵起来，我今晚就跟你走。</p><p>某软件工程师：PHP是最好的语言！</p><p>某论坛真的就炸锅了，各种吵架……</p><p>某女：服了你了，我们走吧，你想干啥都行。</p><p>某软件工程师：今天不行，我一定要说服他们，PHP必须是最好的语言…</p></li><li><p>总结</p><p>这是个情怀的问题，但是不止是情怀的问题；从这个角度来回答，那么任何东西只要能够满足你情怀就是最好的，所以如果php能够支撑起你的梦想，用php能够解决你工作当中遇到的问题，让你能够生活下去，那么它就是最好的语言。</p><p>但是语言只是一个解决问题的工具，不能仅局限于使用某种语言，拥抱开放，才能看的更远，多掌握一种工具，在面对问题的时候就会多一种解决方案，人生永远不要给自己设限。</p><p>php历经多年依然很棒，在web开发领域，依然被广泛使用，也将被长期使用，至少目前没有后来者居上的情况发生。但对每个phper来说，立足当下，着眼未来才是关键，不要固步自封，学会开放的胸怀去面对，走出自己的舒适区，再学至少一门编程语言吧。只有在学习中我们才能进步，这一点其实php本身就在慢慢的改变，只要你有心去注意，你会发现，你所用的几个流行的php开发框架越来越多的在借鉴java的开发思想。php本身都在不断的学习进步，作为一个phper，我们有什么理由原地踏步呢？</p></li></ul><h3 id="PHP3是世界的语言-1"><a href="#PHP3是世界的语言-1" class="headerlink" title="PHP3是世界的语言"></a>PHP3是世界的语言</h3><hr><h4 id="给传统PHP插上翅膀的现代PHP扩展-SWOOLE"><a href="#给传统PHP插上翅膀的现代PHP扩展-SWOOLE" class="headerlink" title="给传统PHP插上翅膀的现代PHP扩展 SWOOLE"></a>给传统PHP插上翅膀的现代PHP扩展 SWOOLE</h4><p><img src="/img/post/2020-11-13/swoole.jpg"></p><ul><li><p>Swore : 让PHP无所不能</p><p>Swoole 使 PHP 开发人员可以编写高性能高并发的 TCP、UDP、Unix Socket、HTTP、 WebSocket 等服务，让 PHP 不再局限于 Web 领域。Swoole4 协程的成熟将 PHP 带入了前所未有的时期， 为性能的提升提供了独一无二的可能性。Swoole 可以广泛应用于互联网、移动通信、云计算、 网络游戏、物联网（IOT）、车联网、智能家居等领域。使用 PHP + Swoole 可以使企业 IT 研发团队的效率大大提升，更加专注于开发创新产品。</p></li></ul><hr><h4 id="如何从PHP过渡到Go-golang"><a href="#如何从PHP过渡到Go-golang" class="headerlink" title="如何从PHP过渡到Go(golang)"></a>如何从PHP过渡到Go(golang)</h4><ul><li><p>Go语言的前世今生</p><p>Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。</p><p>2012年正式发布。</p></li><li><p>Go语言的特性和优势</p><p>go是21世纪的C语言，也是云计算时代的C语言，它的诞生是为了有更高的开发效率。</p><p><strong>go的最大优势就是执行速度和开发效率都很出色，而且从语言级别上支持并发。执行速度快是因为go是编译型的静态语言，它在执行速度上比解释型语言具有先天的优势。生产效率高是基于go的语法和结构简明，易学易用。</strong></p></li></ul><p><img src="/img/post/2020-11-13/golang.jpg"></p><hr><h3 id="博客内容分享既定技术方向和目标"><a href="#博客内容分享既定技术方向和目标" class="headerlink" title="博客内容分享既定技术方向和目标"></a>博客内容分享既定技术方向和目标</h3><ol><li>主要 围绕 PHP和GOLANG 语言在 web 应用中涉及到的 环境搭建 、技术选型及案例分析 展开博客日志记录分享。</li><li>包括但不限于 对 时下 web应用 周边语言、应用或框架、动态新闻 进行跟踪学习分享</li></ol><ul><li><p>Git</p><p>是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 [1] Git 是 [Linus Torvalds] 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p></li><li><p>Docker</p><p>Docker是一个开放源代码软件项目，让应用程序部署在软件货柜下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。</p></li><li><p>Vue.js</p><p>Vue.js是一套构建用户界面的渐进式框架，Vue 采用自下向上增量开发的设计，其核心库只关注视图层，易于上手，同时vue完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> GOLANG </tag>
            
            <tag> ANDPHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程【GO语言基础】</title>
      <link href="2020/03/26/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>2020/03/26/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>现在我们几乎每天都在使用互联网，我们前面已经学习了如何编写Go语言程序，但是如何才能让我们的程序通过网络互相通信呢？本章我们就一起来学习下Go语言中的网络编程。 关于网络编程其实是一个很庞大的领域，本文只是简单的演示了如何使用net包进行TCP和UDP通信。如需了解更详细的网络编程请自行检索和阅读专业资料。</p><hr><h3 id="互联网协议介绍"><a href="#互联网协议介绍" class="headerlink" title="互联网协议介绍"></a>互联网协议介绍</h3><p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。我们理解了这些协议，就理解了互联网的原理。由于这些协议太过庞大和复杂，没有办法在这里一概而全，只能介绍一下我们日常开发中接触较多的几个协议。</p><h4 id="互联网分层模型"><a href="#互联网分层模型" class="headerlink" title="互联网分层模型"></a><font color=#ba3925 >互联网分层模型</font></h4><p>互联网的逻辑实现被分为好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。用户接触到的只是最上面的那一层，根本不会感觉到下面的几层。要理解互联网就需要自下而上理解每一层的实现的功能。</p><p><img src="/img/2020-03-26/osi.png" alt="img"></p><p>如上图所示，互联网按照不同的模型划分会有不用的分层，但是不论按照什么模型去划分，越往上的层越靠近用户，越往下的层越靠近硬件。在软件开发中我们使用最多的是上图中将互联网划分为五个分层的模型。</p><p>接下来我们一层一层的自底向上介绍一下每一层。</p><h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><font color=#ba3925 >物理层</font></h5><p>我们的电脑要与外界互联网通信，需要先把电脑连接网络，我们可以用双绞线、光纤、无线电波等方式。这就叫做”实物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</p><h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><font color=#ba3925 >数据链路层</font></h5><p>单纯的0和1没有任何意义，所以我们使用者会为其赋予一些特定的含义，规定解读电信号的方式：例如：多少个电信号算一组？每个信号位有何意义？这就是”数据链接层”的功能，它在”物理层”的上方，确定了物理层传输的0和1的分组方式及代表的意义。早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。其中”标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。”标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><p>那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><p>我们会通过ARP协议来获取接受方的MAC地址，有了MAC地址之后，如何把数据准确的发送给接收方呢？其实这里以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机都发送，让每台计算机读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p><h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><font color=#ba3925 >网络层</font></h5><p>按照以太网协议的规则我们可以依靠MAC地址来向外发送数据。理论上依靠MAC地址，你电脑的网卡就可以找到身在世界另一个角落的某台电脑的网卡了，但是这种做法有一个重大缺陷就是以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且发送的数据只能局限在发送者所在的子网络。也就是说如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理且必要的，因为如果互联网上每一台计算机都会收到互联网上收发的所有数据包，那是不现实的。</p><p>因此，必须找到一种方法区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p><p>“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是网络管理员分配的。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。IPv4这个版本规定，网络地址由32个二进制位组成，我们通常习惯用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>根据IP协议发送的数据，就叫做IP数据包。IP数据包也分为”标头”和”数据”两个部分：”标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65535字节。</p><h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><font color=#ba3925 >传输层</font></h5><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。但问题是同一台主机上会有许多程序都需要用网络收发数据，比如QQ和浏览器这两个程序都需要连接互联网并收发数据，我们如何区分某个数据包到底是归哪个程序的呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。有了IP和端口我们就能实现唯一确定互联网上一个程序，进而实现网络间的程序通信。</p><p>我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。UDP数据包，也是由”标头”和”数据”两部分组成：”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><font color=#ba3925 >应用层</font></h5><p>应用程序收到”传输层”的数据，接下来就要对数据进行解包。由于互联网是开放架构，数据来源五花八门，必须事先规定好通信的数据格式，否则接收方根本无法获得真正发送的数据内容。”应用层”的作用就是规定应用程序使用的数据格式，例如我们TCP协议之上常见的Email、HTTP、FTP等协议，这些协议就组成了互联网协议的应用层。</p><p>如下图所示，发送方的HTTP数据经过互联网的传输过程中会依次添加各层协议的标头信息，接收方收到数据包之后再依次根据协议解包得到数据。</p><p><img src="/img/2020-03-26/httptcpip.png" alt="img"></p><hr><h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><p>Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p><h4 id="socket图解"><a href="#socket图解" class="headerlink" title="socket图解"></a><font color=#ba3925 >socket图解</font></h4><p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，<code>Socket</code>其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在<code>Socket</code>后面，对用户来说只需要调用Socket规定的相关函数，让<code>Socket</code>去组织符合指定的协议数据然后进行通信。</p><p><img src="/img/2020-03-26/socket.png" alt="img"></p><h4 id="Go语言实现TCP通信"><a href="#Go语言实现TCP通信" class="headerlink" title="Go语言实现TCP通信"></a><font color=#ba3925 >Go语言实现TCP通信</font></h4><h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a><font color=#ba3925 >TCP协议</font></h5><p>TCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。</p><h5 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a><font color=#ba3925 >TCP服务端</font></h5><p>一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为Go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。</p><p>TCP服务端程序的处理流程：</p><ol><li>监听端口</li><li>接收客户端请求建立链接</li><li>创建goroutine处理链接。</li></ol><p>我们使用Go语言的net包实现的TCP服务端代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; tcp&#x2F;server&#x2F;main.go</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TCP server端</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理函数</span><br><span class="line">func process(conn net.Conn) &#123;</span><br><span class="line">defer conn.Close() &#x2F;&#x2F; 关闭连接</span><br><span class="line">for &#123;</span><br><span class="line">reader :&#x3D; bufio.NewReader(conn)</span><br><span class="line">var buf [128]byte</span><br><span class="line">n, err :&#x3D; reader.Read(buf[:]) &#x2F;&#x2F; 读取数据</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;read from client failed, err:&quot;, err)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">recvStr :&#x3D; string(buf[:n])</span><br><span class="line">fmt.Println(&quot;收到client端发来的数据：&quot;, recvStr)</span><br><span class="line">conn.Write([]byte(recvStr)) &#x2F;&#x2F; 发送数据</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">listen, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:20000&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;listen failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">for &#123;</span><br><span class="line">conn, err :&#x3D; listen.Accept() &#x2F;&#x2F; 建立连接</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;accept failed, err:&quot;, err)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">go process(conn) &#x2F;&#x2F; 启动一个goroutine处理连接</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存之后编译成<code>server</code>或<code>server.exe</code>可执行文件。</p><h5 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a><font color=#ba3925 >TCP客户端</font></h5><p>一个TCP客户端进行TCP通信的流程如下：</p><ol><li>建立与服务端的链接</li><li>进行数据收发</li><li>关闭链接</li></ol><p>使用Go语言的net包实现的TCP客户端代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; tcp&#x2F;client&#x2F;main.go</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 客户端</span><br><span class="line">func main() &#123;</span><br><span class="line">conn, err :&#x3D; net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:20000&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;err :&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer conn.Close() &#x2F;&#x2F; 关闭连接</span><br><span class="line">inputReader :&#x3D; bufio.NewReader(os.Stdin)</span><br><span class="line">for &#123;</span><br><span class="line">input, _ :&#x3D; inputReader.ReadString(&#39;\n&#39;) &#x2F;&#x2F; 读取用户输入</span><br><span class="line">inputInfo :&#x3D; strings.Trim(input, &quot;\r\n&quot;)</span><br><span class="line">if strings.ToUpper(inputInfo) &#x3D;&#x3D; &quot;Q&quot; &#123; &#x2F;&#x2F; 如果输入q就退出</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">_, err &#x3D; conn.Write([]byte(inputInfo)) &#x2F;&#x2F; 发送数据</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">buf :&#x3D; [512]byte&#123;&#125;</span><br><span class="line">n, err :&#x3D; conn.Read(buf[:])</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;recv failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(string(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译成<code>client</code>或<code>client.exe</code>可执行文件，先启动server端再启动client端，在client端输入任意内容回车之后就能够在server端看到client端发送的数据，从而实现TCP通信。</p><h4 id="TCP黏包"><a href="#TCP黏包" class="headerlink" title="TCP黏包"></a><font color=#ba3925 >TCP黏包</font></h4><h5 id="黏包示例"><a href="#黏包示例" class="headerlink" title="黏包示例"></a><font color=#ba3925 >黏包示例</font></h5><p>服务端代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; socket_stick&#x2F;server&#x2F;main.go</span><br><span class="line"></span><br><span class="line">func process(conn net.Conn) &#123;</span><br><span class="line">defer conn.Close()</span><br><span class="line">reader :&#x3D; bufio.NewReader(conn)</span><br><span class="line">var buf [1024]byte</span><br><span class="line">for &#123;</span><br><span class="line">n, err :&#x3D; reader.Read(buf[:])</span><br><span class="line">if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;read from client failed, err:&quot;, err)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">recvStr :&#x3D; string(buf[:n])</span><br><span class="line">fmt.Println(&quot;收到client发来的数据：&quot;, recvStr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">listen, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:30000&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;listen failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer listen.Close()</span><br><span class="line">for &#123;</span><br><span class="line">conn, err :&#x3D; listen.Accept()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;accept failed, err:&quot;, err)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">go process(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; socket_stick&#x2F;client&#x2F;main.go</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">conn, err :&#x3D; net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:30000&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;dial failed, err&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer conn.Close()</span><br><span class="line">for i :&#x3D; 0; i &lt; 20; i++ &#123;</span><br><span class="line">msg :&#x3D; &#96;Hello, Hello. How are you?&#96;</span><br><span class="line">conn.Write([]byte(msg))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码保存后，分别编译。先启动服务端再启动客户端，可以看到服务端输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?</span><br><span class="line">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?</span><br></pre></td></tr></table></figure><p>客户端分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。</p><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ol><li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li></ol><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><font color=#ba3925 >解决办法</font></h5><p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p><p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p><p>我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; socket_stick&#x2F;proto&#x2F;proto.go</span><br><span class="line">package proto</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bufio&quot;</span><br><span class="line">&quot;bytes&quot;</span><br><span class="line">&quot;encoding&#x2F;binary&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Encode 将消息编码</span><br><span class="line">func Encode(message string) ([]byte, error) &#123;</span><br><span class="line">&#x2F;&#x2F; 读取消息的长度，转换成int32类型（占4个字节）</span><br><span class="line">var length &#x3D; int32(len(message))</span><br><span class="line">var pkg &#x3D; new(bytes.Buffer)</span><br><span class="line">&#x2F;&#x2F; 写入消息头</span><br><span class="line">err :&#x3D; binary.Write(pkg, binary.LittleEndian, length)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 写入消息实体</span><br><span class="line">err &#x3D; binary.Write(pkg, binary.LittleEndian, []byte(message))</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">return pkg.Bytes(), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Decode 解码消息</span><br><span class="line">func Decode(reader *bufio.Reader) (string, error) &#123;</span><br><span class="line">&#x2F;&#x2F; 读取消息的长度</span><br><span class="line">lengthByte, _ :&#x3D; reader.Peek(4) &#x2F;&#x2F; 读取前4个字节的数据</span><br><span class="line">lengthBuff :&#x3D; bytes.NewBuffer(lengthByte)</span><br><span class="line">var length int32</span><br><span class="line">err :&#x3D; binary.Read(lengthBuff, binary.LittleEndian, &amp;length)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Buffered返回缓冲中现有的可读取的字节数。</span><br><span class="line">if int32(reader.Buffered()) &lt; length+4 &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读取真正的消息数据</span><br><span class="line">pack :&#x3D; make([]byte, int(4+length))</span><br><span class="line">_, err &#x3D; reader.Read(pack)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line">return string(pack[4:]), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在服务端和客户端分别使用上面定义的<code>proto</code>包的<code>Decode</code>和<code>Encode</code>函数处理数据。</p><p>服务端代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; socket_stick&#x2F;server2&#x2F;main.go</span><br><span class="line"></span><br><span class="line">func process(conn net.Conn) &#123;</span><br><span class="line">defer conn.Close()</span><br><span class="line">reader :&#x3D; bufio.NewReader(conn)</span><br><span class="line">for &#123;</span><br><span class="line">msg, err :&#x3D; proto.Decode(reader)</span><br><span class="line">if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;decode msg failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;收到client发来的数据：&quot;, msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">listen, err :&#x3D; net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:30000&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;listen failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer listen.Close()</span><br><span class="line">for &#123;</span><br><span class="line">conn, err :&#x3D; listen.Accept()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;accept failed, err:&quot;, err)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">go process(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; socket_stick&#x2F;client2&#x2F;main.go</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">conn, err :&#x3D; net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:30000&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;dial failed, err&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer conn.Close()</span><br><span class="line">for i :&#x3D; 0; i &lt; 20; i++ &#123;</span><br><span class="line">msg :&#x3D; &#96;Hello, Hello. How are you?&#96;</span><br><span class="line">data, err :&#x3D; proto.Encode(msg)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;encode msg failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">conn.Write(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Go语言实现UDP通信"><a href="#Go语言实现UDP通信" class="headerlink" title="Go语言实现UDP通信"></a><font color=#ba3925 >Go语言实现UDP通信</font></h4><h5 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a><font color=#ba3925 >UDP协议</font></h5><p>UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种<strong>无连接</strong>的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。</p><h5 id="UDP服务端"><a href="#UDP服务端" class="headerlink" title="UDP服务端"></a><font color=#ba3925 >UDP服务端</font></h5><p>使用Go语言的<code>net</code>包实现的UDP服务端代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; UDP&#x2F;server&#x2F;main.go</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; UDP server端</span><br><span class="line">func main() &#123;</span><br><span class="line">listen, err :&#x3D; net.ListenUDP(&quot;udp&quot;, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(0, 0, 0, 0),</span><br><span class="line">Port: 30000,</span><br><span class="line">&#125;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;listen failed, err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer listen.Close()</span><br><span class="line">for &#123;</span><br><span class="line">var data [1024]byte</span><br><span class="line">n, addr, err :&#x3D; listen.ReadFromUDP(data[:]) &#x2F;&#x2F; 接收数据</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;read udp failed, err:&quot;, err)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;data:%v addr:%v count:%v\n&quot;, string(data[:n]), addr, n)</span><br><span class="line">_, err &#x3D; listen.WriteToUDP(data[:n], addr) &#x2F;&#x2F; 发送数据</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;write to udp failed, err:&quot;, err)</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a><font color=#ba3925 >UDP客户端</font></h5><p>使用Go语言的<code>net</code>包实现的UDP客户端代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; UDP 客户端</span><br><span class="line">func main() &#123;</span><br><span class="line">socket, err :&#x3D; net.DialUDP(&quot;udp&quot;, nil, &amp;net.UDPAddr&#123;</span><br><span class="line">IP:   net.IPv4(0, 0, 0, 0),</span><br><span class="line">Port: 30000,</span><br><span class="line">&#125;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;连接服务端失败，err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer socket.Close()</span><br><span class="line">sendData :&#x3D; []byte(&quot;Hello server&quot;)</span><br><span class="line">_, err &#x3D; socket.Write(sendData) &#x2F;&#x2F; 发送数据</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;发送数据失败，err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">data :&#x3D; make([]byte, 4096)</span><br><span class="line">n, remoteAddr, err :&#x3D; socket.ReadFromUDP(data) &#x2F;&#x2F; 接收数据</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;接收数据失败，err:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;recv:%v addr:%v count:%v\n&quot;, string(data[:n]), remoteAddr, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发【GO语言基础】</title>
      <link href="2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/"/>
      <url>2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发，这也是Go语言流行的一个很重要的原因。</p><hr><h3 id="Go语言中的并发编程"><a href="#Go语言中的并发编程" class="headerlink" title="Go语言中的并发编程"></a>Go语言中的并发编程</h3><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><font color=#ba3925 >并发与并行</font></h4><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p><p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a><font color=#ba3925 >goroutine</font></h4><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 <code>goroutine</code> 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p><h4 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a><font color=#ba3925 >使用goroutine</font></h4><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p><p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p><h5 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a><font color=#ba3925 >启动单个goroutine</font></h5><p>启动<code>goroutine</code>的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p><p>举个例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func hello() &#123;</span><br><span class="line">fmt.Println(&quot;Hello Goroutine!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">hello()</span><br><span class="line">fmt.Println(&quot;main goroutine done!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p><p>接下来我们在调用hello函数前面加上关键字go，也就是启动一个goroutine去执行hello这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">go hello() &#x2F;&#x2F; 启动另外一个goroutine去执行hello函数</span><br><span class="line">fmt.Println(&quot;main goroutine done!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p><p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">go hello() &#x2F;&#x2F; 启动另外一个goroutine去执行hello函数</span><br><span class="line">fmt.Println(&quot;main goroutine done!&quot;)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p><p>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p><h5 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a><font color=#ba3925 >启动多个goroutine</font></h5><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func hello(i int) &#123;</span><br><span class="line">defer wg.Done() &#x2F;&#x2F; goroutine结束就登记-1</span><br><span class="line">fmt.Println(&quot;Hello Goroutine!&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">wg.Add(1) &#x2F;&#x2F; 启动一个goroutine就登记+1</span><br><span class="line">go hello(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() &#x2F;&#x2F; 等待所有登记的goroutine都结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p><h4 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a><font color=#ba3925 >goroutine与线程</font></h4><h5 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a><font color=#ba3925 >可增长的栈</font></h5><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p><h5 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a><font color=#ba3925 >goroutine调度</font></h5><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p><ul><li>G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li><li>P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li><li>M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li></ul><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html">点我了解更多</a></p><h4 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a><font color=#ba3925 >GOMAXPROCS</font></h4><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">for i :&#x3D; 1; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Println(&quot;A:&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func b() &#123;</span><br><span class="line">for i :&#x3D; 1; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Println(&quot;B:&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">runtime.GOMAXPROCS(1)</span><br><span class="line">go a()</span><br><span class="line">go b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">for i :&#x3D; 1; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Println(&quot;A:&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func b() &#123;</span><br><span class="line">for i :&#x3D; 1; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Println(&quot;B:&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">runtime.GOMAXPROCS(2)</span><br><span class="line">go a()</span><br><span class="line">go b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中的操作系统线程和goroutine的关系：</p><ol><li>一个操作系统线程对应用户态多个goroutine。</li><li>go程序可以同时使用多个操作系统线程。</li><li>goroutine和OS线程是多对多的关系，即m:n。</li></ol><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a><font color=#ba3925 >channel</font></h4><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h5 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a><font color=#ba3925 >channel类型</font></h5><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量 chan 元素类型</span><br></pre></td></tr></table></figure><p>举几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ch1 chan int   &#x2F;&#x2F; 声明一个传递整型的通道</span><br><span class="line">var ch2 chan bool  &#x2F;&#x2F; 声明一个传递布尔型的通道</span><br><span class="line">var ch3 chan []int &#x2F;&#x2F; 声明一个传递int切片的通道</span><br></pre></td></tr></table></figure><h5 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a><font color=#ba3925 >创建channel</font></h5><p>通道是引用类型，通道类型的空值是nil。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ch chan int</span><br><span class="line">fmt.Println(ch) &#x2F;&#x2F; &lt;nil&gt;</span><br></pre></td></tr></table></figure><p>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</p><p>创建channel的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make(chan 元素类型, [缓冲大小])</span><br><span class="line">channel的缓冲大小是可选的。</span><br></pre></td></tr></table></figure><p>举几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 :&#x3D; make(chan int)</span><br><span class="line">ch5 :&#x3D; make(chan bool)</span><br><span class="line">ch6 :&#x3D; make(chan []int)</span><br></pre></td></tr></table></figure><h5 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a><font color=#ba3925 >channel操作</font></h5><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>现在我们先使用以下语句定义一个通道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int)</span><br></pre></td></tr></table></figure><h6 id="发送"><a href="#发送" class="headerlink" title="发送"></a><font color=#ba3925 >发送</font></h6><p>将一个值发送到通道中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- 10 &#x2F;&#x2F; 把10发送到ch中</span><br></pre></td></tr></table></figure><h6 id="发送-1"><a href="#发送-1" class="headerlink" title="发送"></a><font color=#ba3925 >发送</font></h6><p>从一个通道中接收值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x :&#x3D; &lt;- ch &#x2F;&#x2F; 从ch中接收值并赋值给变量x</span><br><span class="line">&lt;-ch       &#x2F;&#x2F; 从ch中接收值，忽略结果</span><br></pre></td></tr></table></figure><h6 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a><font color=#ba3925 >关闭</font></h6><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(ch)</span><br></pre></td></tr></table></figure><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><h4 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a><font color=#ba3925 >无缓冲的通道</font></h4><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line">ch &lt;- 10</span><br><span class="line">fmt.Println(&quot;发送成功&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        ...&#x2F;src&#x2F;github.com&#x2F;Q1mi&#x2F;studygo&#x2F;day06&#x2F;channel02&#x2F;main.go:8 +0x54</span><br></pre></td></tr></table></figure><p>为什么会出现<code>deadlock</code>错误呢？</p><p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p><p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func recv(c chan int) &#123;</span><br><span class="line">ret :&#x3D; &lt;-c</span><br><span class="line">fmt.Println(&quot;接收成功&quot;, ret)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line">go recv(ch) &#x2F;&#x2F; 启用goroutine从通道接收值</span><br><span class="line">ch &lt;- 10</span><br><span class="line">fmt.Println(&quot;发送成功&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的<code>goroutine</code>将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h4 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a><font color=#ba3925 >有缓冲的通道</font></h4><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">ch :&#x3D; make(chan int, 1) &#x2F;&#x2F; 创建一个容量为1的有缓冲区通道</span><br><span class="line">ch &lt;- 10</span><br><span class="line">fmt.Println(&quot;发送成功&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h4 id="for-range从通道循环取值"><a href="#for-range从通道循环取值" class="headerlink" title="for range从通道循环取值"></a><font color=#ba3925 >for range从通道循环取值</font></h4><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p><p>当通道被关闭时，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？</p><p>我们来看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; channel 练习</span><br><span class="line">func main() &#123;</span><br><span class="line">ch1 :&#x3D; make(chan int)</span><br><span class="line">ch2 :&#x3D; make(chan int)</span><br><span class="line">&#x2F;&#x2F; 开启goroutine将0~100的数发送到ch1中</span><br><span class="line">go func() &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; 100; i++ &#123;</span><br><span class="line">ch1 &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(ch1)</span><br><span class="line">&#125;()</span><br><span class="line">&#x2F;&#x2F; 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">i, ok :&#x3D; &lt;-ch1 &#x2F;&#x2F; 通道关闭后再取值ok&#x3D;false</span><br><span class="line">if !ok &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">ch2 &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line">close(ch2)</span><br><span class="line">&#125;()</span><br><span class="line">&#x2F;&#x2F; 在主goroutine中从ch2中接收值打印</span><br><span class="line">for i :&#x3D; range ch2 &#123; &#x2F;&#x2F; 通道关闭后会退出for range循环</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p><h4 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a><font color=#ba3925 >单向通道</font></h4><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><p>Go语言中提供了<code>单向通道</code>来处理这种情况。例如，我们把上面的例子改造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func counter(out chan&lt;- int) &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; 100; i++ &#123;</span><br><span class="line">out &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">close(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func squarer(out chan&lt;- int, in &lt;-chan int) &#123;</span><br><span class="line">for i :&#x3D; range in &#123;</span><br><span class="line">out &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line">close(out)</span><br><span class="line">&#125;</span><br><span class="line">func printer(in &lt;-chan int) &#123;</span><br><span class="line">for i :&#x3D; range in &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch1 :&#x3D; make(chan int)</span><br><span class="line">ch2 :&#x3D; make(chan int)</span><br><span class="line">go counter(ch1)</span><br><span class="line">go squarer(ch2, ch1)</span><br><span class="line">printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li><li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li></ul><p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p><h4 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a><font color=#ba3925 >通道总结</font></h4><p><code>channel</code>常见的异常总结，如下图：</p><p><img src="/img/2020-03-25/channel01.png" alt="img"></p><p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p><h4 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a><font color=#ba3925 >worker pool（goroutine池）</font></h4><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p><p>一个简易的<code>work pool</code>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func worker(id int, jobs &lt;-chan int, results chan&lt;- int) &#123;</span><br><span class="line">for j :&#x3D; range jobs &#123;</span><br><span class="line">fmt.Printf(&quot;worker:%d start job:%d\n&quot;, id, j)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Printf(&quot;worker:%d end job:%d\n&quot;, id, j)</span><br><span class="line">results &lt;- j * 2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">jobs :&#x3D; make(chan int, 100)</span><br><span class="line">results :&#x3D; make(chan int, 100)</span><br><span class="line">&#x2F;&#x2F; 开启3个goroutine</span><br><span class="line">for w :&#x3D; 1; w &lt;&#x3D; 3; w++ &#123;</span><br><span class="line">go worker(w, jobs, results)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 5个任务</span><br><span class="line">for j :&#x3D; 1; j &lt;&#x3D; 5; j++ &#123;</span><br><span class="line">jobs &lt;- j</span><br><span class="line">&#125;</span><br><span class="line">close(jobs)</span><br><span class="line">&#x2F;&#x2F; 输出结果</span><br><span class="line">for a :&#x3D; 1; a &lt;&#x3D; 5; a++ &#123;</span><br><span class="line">&lt;-results</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a><font color=#ba3925 >select多路复用</font></h4><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for&#123;</span><br><span class="line">    &#x2F;&#x2F; 尝试从ch1接收值</span><br><span class="line">    data, ok :&#x3D; &lt;-ch1</span><br><span class="line">    &#x2F;&#x2F; 尝试从ch2接收值</span><br><span class="line">    data, ok :&#x3D; &lt;-ch2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了select关键字，可以同时响应多个通道的操作。</p><p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select&#123;</span><br><span class="line">    case &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    case data :&#x3D; &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    case ch3&lt;-data:</span><br><span class="line">        ...</span><br><span class="line">    default:</span><br><span class="line">        默认操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个小例子来演示下select的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">ch :&#x3D; make(chan int, 1)</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case x :&#x3D; &lt;-ch:</span><br><span class="line">fmt.Println(x)</span><br><span class="line">case ch &lt;- i:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>select</code>语句能提高代码的可读性。</p><ul><li>可处理一个或多个channel的发送/接收操作。</li><li>如果多个case同时满足，select会随机选择一个。</li><li>对于没有case的select{}会一直等待，可用于阻塞main函数。</li></ul><h4 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a><font color=#ba3925 >并发安全和锁</font></h4><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var x int64</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func add() &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; 5000; i++ &#123;</span><br><span class="line">x &#x3D; x + 1</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(2)</span><br><span class="line">go add()</span><br><span class="line">go add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量<code>x</code>的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><font color=#ba3925 >互斥锁</font></h4><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var x int64</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">var lock sync.Mutex</span><br><span class="line"></span><br><span class="line">func add() &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; 5000; i++ &#123;</span><br><span class="line">lock.Lock() &#x2F;&#x2F; 加锁</span><br><span class="line">x &#x3D; x + 1</span><br><span class="line">lock.Unlock() &#x2F;&#x2F; 解锁</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(2)</span><br><span class="line">go add()</span><br><span class="line">go add()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p><h4 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a><font color=#ba3925 >读写互斥锁</font></h4><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p>读写锁分为两种：读锁和写锁。当一个<code>goroutine</code>获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p><p>读写锁示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">x      int64</span><br><span class="line">wg     sync.WaitGroup</span><br><span class="line">lock   sync.Mutex</span><br><span class="line">rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func write() &#123;</span><br><span class="line">&#x2F;&#x2F; lock.Lock()   &#x2F;&#x2F; 加互斥锁</span><br><span class="line">rwlock.Lock() &#x2F;&#x2F; 加写锁</span><br><span class="line">x &#x3D; x + 1</span><br><span class="line">time.Sleep(10 * time.Millisecond) &#x2F;&#x2F; 假设读操作耗时10毫秒</span><br><span class="line">rwlock.Unlock()                   &#x2F;&#x2F; 解写锁</span><br><span class="line">&#x2F;&#x2F; lock.Unlock()                     &#x2F;&#x2F; 解互斥锁</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func read() &#123;</span><br><span class="line">&#x2F;&#x2F; lock.Lock()                  &#x2F;&#x2F; 加互斥锁</span><br><span class="line">rwlock.RLock()               &#x2F;&#x2F; 加读锁</span><br><span class="line">time.Sleep(time.Millisecond) &#x2F;&#x2F; 假设读操作耗时1毫秒</span><br><span class="line">rwlock.RUnlock()             &#x2F;&#x2F; 解读锁</span><br><span class="line">&#x2F;&#x2F; lock.Unlock()                &#x2F;&#x2F; 解互斥锁</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">start :&#x3D; time.Now()</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; 1000; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go read()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">end :&#x3D; time.Now()</span><br><span class="line">fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p><h4 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a><font color=#ba3925 >sync.WaitGroup</font></h4><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>(wg * WaitGroup) Add(delta int)</td><td>计数器+delta</td></tr><tr><td>(wg *WaitGroup) Done()</td><td>计数器-1</td></tr><tr><td>(wg *WaitGroup) Wait()</td><td>阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p><p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func hello() &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;Hello Goroutine!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go hello() &#x2F;&#x2F; 启动另外一个goroutine去执行hello函数</span><br><span class="line">fmt.Println(&quot;main goroutine done!&quot;)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p><h4 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a><font color=#ba3925 >sync.Once</font></h4><p>说在前面的话：这是一个进阶知识点。</p><p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p><p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (o *Once) Do(f func()) &#123;&#125;</span><br></pre></td></tr></table></figure><p>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</p><h5 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a><font color=#ba3925 >加载配置文件示例</font></h5><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var icons map[string]image.Image</span><br><span class="line"></span><br><span class="line">func loadIcons() &#123;</span><br><span class="line">icons &#x3D; map[string]image.Image&#123;</span><br><span class="line">&quot;left&quot;:  loadIcon(&quot;left.png&quot;),</span><br><span class="line">&quot;up&quot;:    loadIcon(&quot;up.png&quot;),</span><br><span class="line">&quot;right&quot;: loadIcon(&quot;right.png&quot;),</span><br><span class="line">&quot;down&quot;:  loadIcon(&quot;down.png&quot;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Icon 被多个goroutine调用时不是并发安全的</span><br><span class="line">func Icon(name string) image.Image &#123;</span><br><span class="line">if icons &#x3D;&#x3D; nil &#123;</span><br><span class="line">loadIcons()</span><br><span class="line">&#125;</span><br><span class="line">return icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func loadIcons() &#123;</span><br><span class="line">icons &#x3D; make(map[string]image.Image)</span><br><span class="line">icons[&quot;left&quot;] &#x3D; loadIcon(&quot;left.png&quot;)</span><br><span class="line">icons[&quot;up&quot;] &#x3D; loadIcon(&quot;up.png&quot;)</span><br><span class="line">icons[&quot;right&quot;] &#x3D; loadIcon(&quot;right.png&quot;)</span><br><span class="line">icons[&quot;down&quot;] &#x3D; loadIcon(&quot;down.png&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var icons map[string]image.Image</span><br><span class="line"></span><br><span class="line">var loadIconsOnce sync.Once</span><br><span class="line"></span><br><span class="line">func loadIcons() &#123;</span><br><span class="line">icons &#x3D; map[string]image.Image&#123;</span><br><span class="line">&quot;left&quot;:  loadIcon(&quot;left.png&quot;),</span><br><span class="line">&quot;up&quot;:    loadIcon(&quot;up.png&quot;),</span><br><span class="line">&quot;right&quot;: loadIcon(&quot;right.png&quot;),</span><br><span class="line">&quot;down&quot;:  loadIcon(&quot;down.png&quot;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Icon 是并发安全的</span><br><span class="line">func Icon(name string) image.Image &#123;</span><br><span class="line">loadIconsOnce.Do(loadIcons)</span><br><span class="line">return icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="并发安全的单例模式"><a href="#并发安全的单例模式" class="headerlink" title="并发安全的单例模式"></a><font color=#ba3925 >并发安全的单例模式</font></h5><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package singleton</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type singleton struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">var instance *singleton</span><br><span class="line">var once sync.Once</span><br><span class="line"></span><br><span class="line">func GetInstance() *singleton &#123;</span><br><span class="line">    once.Do(func() &#123;</span><br><span class="line">        instance &#x3D; &amp;singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h4 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a><font color=#ba3925 >sync.Map</font></h4><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var m &#x3D; make(map[string]int)</span><br><span class="line"></span><br><span class="line">func get(key string) int &#123;</span><br><span class="line">return m[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func set(key string, value int) &#123;</span><br><span class="line">m[key] &#x3D; value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg :&#x3D; sync.WaitGroup&#123;&#125;</span><br><span class="line">for i :&#x3D; 0; i &lt; 20; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func(n int) &#123;</span><br><span class="line">key :&#x3D; strconv.Itoa(n)</span><br><span class="line">set(key, n)</span><br><span class="line">fmt.Printf(&quot;k&#x3D;:%v,v:&#x3D;%v\n&quot;, key, get(key))</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p><p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var m &#x3D; sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg :&#x3D; sync.WaitGroup&#123;&#125;</span><br><span class="line">for i :&#x3D; 0; i &lt; 20; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func(n int) &#123;</span><br><span class="line">key :&#x3D; strconv.Itoa(n)</span><br><span class="line">m.Store(key, n)</span><br><span class="line">value, _ :&#x3D; m.Load(key)</span><br><span class="line">fmt.Printf(&quot;k&#x3D;:%v,v:&#x3D;%v\n&quot;, key, value)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a><font color=#ba3925 >原子操作</font></h4><p>代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是Go语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h5 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a><font color=#ba3925 >atomic包</font></h5><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>func LoadInt32(addr *int32) (val int32)<br>func LoadInt64(addr *int64) (val int64)<br>func LoadUint32(addr *uint32) (val uint32)<br>func LoadUint64(addr *uint64) (val uint64)<br>func LoadUintptr(addr *uintptr) (val uintptr)<br>func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td>读取操作</td></tr><tr><td>func StoreInt32(addr *int32, val int32)<br>func StoreInt64(addr *int64, val int64)<br>func StoreUint32(addr *uint32, val uint32)<br>func StoreUint64(addr *uint64, val uint64)<br>func StoreUintptr(addr *uintptr, val uintptr)<br>func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td>写入操作</td></tr><tr><td>func AddInt32(addr *int32, delta int32) (new int32)<br>func AddInt64(addr *int64, delta int64) (new int64)<br>func AddUint32(addr *uint32, delta uint32) (new uint32)<br></td><td></td></tr><tr><td>func AddUint64(addr *uint64, delta uint64) (new uint64)<br>func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td>修改操作</td></tr><tr><td>func SwapInt32(addr *int32, new int32) (old int32)<br>func SwapInt64(addr *int64, new int64) (old int64)<br>func SwapUint32(addr *uint32, new uint32) (old uint32)<br>func SwapUint64(addr *uint64, new uint64) (old uint64)<br>func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)<br>func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td>交换操作</td></tr><tr><td>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)<br>func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)<br>func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)<br>func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)<br>func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)<br>func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td>比较并交换操作</td></tr></tbody></table><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><font color=#ba3925 >示例</font></h5><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;sync&#x2F;atomic&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Counter interface &#123;</span><br><span class="line">Inc()</span><br><span class="line">Load() int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 普通版</span><br><span class="line">type CommonCounter struct &#123;</span><br><span class="line">counter int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c CommonCounter) Inc() &#123;</span><br><span class="line">c.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c CommonCounter) Load() int64 &#123;</span><br><span class="line">return c.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 互斥锁版</span><br><span class="line">type MutexCounter struct &#123;</span><br><span class="line">counter int64</span><br><span class="line">lock    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *MutexCounter) Inc() &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line">defer m.lock.Unlock()</span><br><span class="line">m.counter++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *MutexCounter) Load() int64 &#123;</span><br><span class="line">m.lock.Lock()</span><br><span class="line">defer m.lock.Unlock()</span><br><span class="line">return m.counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 原子操作版</span><br><span class="line">type AtomicCounter struct &#123;</span><br><span class="line">counter int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AtomicCounter) Inc() &#123;</span><br><span class="line">atomic.AddInt64(&amp;a.counter, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AtomicCounter) Load() int64 &#123;</span><br><span class="line">return atomic.LoadInt64(&amp;a.counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test(c Counter) &#123;</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">start :&#x3D; time.Now()</span><br><span class="line">for i :&#x3D; 0; i &lt; 1000; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func() &#123;</span><br><span class="line">c.Inc()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">end :&#x3D; time.Now()</span><br><span class="line">fmt.Println(c.Load(), end.Sub(start))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c1 :&#x3D; CommonCounter&#123;&#125; &#x2F;&#x2F; 非并发安全</span><br><span class="line">test(c1)</span><br><span class="line">c2 :&#x3D; MutexCounter&#123;&#125; &#x2F;&#x2F; 使用互斥锁实现并发安全</span><br><span class="line">test(&amp;c2)</span><br><span class="line">c3 :&#x3D; AtomicCounter&#123;&#125; &#x2F;&#x2F; 并发安全且比互斥锁效率更高</span><br><span class="line">test(&amp;c3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p><hr><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li>使用<code>goroutine</code>和<code>channel</code>实现一个计算int64随机数各位数和的程序。<ol><li>开启一个<code>goroutine</code>循环生成int64类型的随机数，发送到<code>jobChan</code></li><li>开启24个<code>goroutine</code>从<code>jobChan</code>中取出随机数计算各位数的和，将结果发送到<code>resultChan</code><br>主goroutine从resultChan取出结果并打印到终端输出</li></ol></li><li>为了保证业务代码的执行性能将之前写的日志库改写为异步记录日志方式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射【GO语言基础】</title>
      <link href="2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/"/>
      <url>2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了Go语言反射的意义和基本使用。</p><hr><h3 id="变量的内在机制"><a href="#变量的内在机制" class="headerlink" title="变量的内在机制"></a>变量的内在机制</h3><p>Go语言中的变量是分为两部分的:</p><ul><li>类型信息：预先定义好的元信息。</li><li>值信息：程序运行过程中可动态变化的。</li></ul><hr><h3 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h3><p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p><p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>Go程序在运行期使用reflect包访问程序的反射信息。</p><p>在上一篇博客中我们介绍了空接口。 空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？ 反射就是在运行时动态的获取一个变量的类型信息和值信息。</p><hr><h3 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h3><p>在Go语言的反射机制中，任何接口值都由是<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由reflect.Type和reflect.Value两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p><h4 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a><font color=#ba3925 >TypeOf</font></h4><p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func reflectType(x interface&#123;&#125;) &#123;</span><br><span class="line">v :&#x3D; reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(&quot;type:%v\n&quot;, v)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var a float32 &#x3D; 3.14</span><br><span class="line">reflectType(a) &#x2F;&#x2F; type:float32</span><br><span class="line">var b int64 &#x3D; 100</span><br><span class="line">reflectType(b) &#x2F;&#x2F; type:int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="type-name和type-kind"><a href="#type-name和type-kind" class="headerlink" title="type name和type kind"></a><font color=#ba3925 >type name和type kind</font></h4><p>在反射中关于类型还划分为两种：<code>类型（Type)</code>和种类<code>（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type myInt int64</span><br><span class="line"></span><br><span class="line">func reflectType(x interface&#123;&#125;) &#123;</span><br><span class="line">t :&#x3D; reflect.TypeOf(x)</span><br><span class="line">fmt.Printf(&quot;type:%v kind:%v\n&quot;, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a *float32 &#x2F;&#x2F; 指针</span><br><span class="line">var b myInt    &#x2F;&#x2F; 自定义类型</span><br><span class="line">var c rune     &#x2F;&#x2F; 类型别名</span><br><span class="line">reflectType(a) &#x2F;&#x2F; type: kind:ptr</span><br><span class="line">reflectType(b) &#x2F;&#x2F; type:myInt kind:int64</span><br><span class="line">reflectType(c) &#x2F;&#x2F; type:int32 kind:int32</span><br><span class="line"></span><br><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">age  int</span><br><span class="line">&#125;</span><br><span class="line">type book struct&#123; title string &#125;</span><br><span class="line">var d &#x3D; person&#123;</span><br><span class="line">name: &quot;沙河小王子&quot;,</span><br><span class="line">age:  18,</span><br><span class="line">&#125;</span><br><span class="line">var e &#x3D; book&#123;title: &quot;《跟小王子学Go语言》&quot;&#125;</span><br><span class="line">reflectType(d) &#x2F;&#x2F; type:person kind:struct</span><br><span class="line">reflectType(e) &#x2F;&#x2F; type:book kind:struct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的<code>.Name()</code>都是返回空。</p><p>在<code>reflect</code>包中定义的Kind类型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Kind uint</span><br><span class="line">const (</span><br><span class="line">    Invalid Kind &#x3D; iota  &#x2F;&#x2F; 非法类型</span><br><span class="line">    Bool                 &#x2F;&#x2F; 布尔型</span><br><span class="line">    Int                  &#x2F;&#x2F; 有符号整型</span><br><span class="line">    Int8                 &#x2F;&#x2F; 有符号8位整型</span><br><span class="line">    Int16                &#x2F;&#x2F; 有符号16位整型</span><br><span class="line">    Int32                &#x2F;&#x2F; 有符号32位整型</span><br><span class="line">    Int64                &#x2F;&#x2F; 有符号64位整型</span><br><span class="line">    Uint                 &#x2F;&#x2F; 无符号整型</span><br><span class="line">    Uint8                &#x2F;&#x2F; 无符号8位整型</span><br><span class="line">    Uint16               &#x2F;&#x2F; 无符号16位整型</span><br><span class="line">    Uint32               &#x2F;&#x2F; 无符号32位整型</span><br><span class="line">    Uint64               &#x2F;&#x2F; 无符号64位整型</span><br><span class="line">    Uintptr              &#x2F;&#x2F; 指针</span><br><span class="line">    Float32              &#x2F;&#x2F; 单精度浮点数</span><br><span class="line">    Float64              &#x2F;&#x2F; 双精度浮点数</span><br><span class="line">    Complex64            &#x2F;&#x2F; 64位复数类型</span><br><span class="line">    Complex128           &#x2F;&#x2F; 128位复数类型</span><br><span class="line">    Array                &#x2F;&#x2F; 数组</span><br><span class="line">    Chan                 &#x2F;&#x2F; 通道</span><br><span class="line">    Func                 &#x2F;&#x2F; 函数</span><br><span class="line">    Interface            &#x2F;&#x2F; 接口</span><br><span class="line">    Map                  &#x2F;&#x2F; 映射</span><br><span class="line">    Ptr                  &#x2F;&#x2F; 指针</span><br><span class="line">    Slice                &#x2F;&#x2F; 切片</span><br><span class="line">    String               &#x2F;&#x2F; 字符串</span><br><span class="line">    Struct               &#x2F;&#x2F; 结构体</span><br><span class="line">    UnsafePointer        &#x2F;&#x2F; 底层指针</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a><font color=#ba3925 >ValueOf</font></h4><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。<code>reflect.Value</code>与原始值之间可以互相转换。</p><p><code>reflect.Value</code>类型提供的获取原始值的方法如下：</p><p>|方法｜    说明｜<br>｜—｜—｜<br>｜Interface() interface {}    ｜将值以 interface{} 类型返回，可以通过类型断言转换为指定类型｜<br>｜Int() int64    ｜将值以 int 类型返回，所有有符号整型均可以此方式返回｜<br>｜Uint() uint64    ｜将值以 uint 类型返回，所有无符号整型均可以此方式返回｜<br>｜Float() float64    ｜将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回｜<br>｜Bool() bool    ｜将值以 bool 类型返回｜<br>｜Bytes() []bytes    ｜将值以字节数组 []bytes 类型返回｜<br>｜String() string    ｜将值以字符串类型返回｜</p><h5 id="通过反射获取值"><a href="#通过反射获取值" class="headerlink" title="通过反射获取值"></a><font color=#ba3925 >通过反射获取值</font></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func reflectValue(x interface&#123;&#125;) &#123;</span><br><span class="line">v :&#x3D; reflect.ValueOf(x)</span><br><span class="line">k :&#x3D; v.Kind()</span><br><span class="line">switch k &#123;</span><br><span class="line">case reflect.Int64:</span><br><span class="line">&#x2F;&#x2F; v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span><br><span class="line">fmt.Printf(&quot;type is int64, value is %d\n&quot;, int64(v.Int()))</span><br><span class="line">case reflect.Float32:</span><br><span class="line">&#x2F;&#x2F; v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span><br><span class="line">fmt.Printf(&quot;type is float32, value is %f\n&quot;, float32(v.Float()))</span><br><span class="line">case reflect.Float64:</span><br><span class="line">&#x2F;&#x2F; v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span><br><span class="line">fmt.Printf(&quot;type is float64, value is %f\n&quot;, float64(v.Float()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var a float32 &#x3D; 3.14</span><br><span class="line">var b int64 &#x3D; 100</span><br><span class="line">reflectValue(a) &#x2F;&#x2F; type is float32, value is 3.140000</span><br><span class="line">reflectValue(b) &#x2F;&#x2F; type is int64, value is 100</span><br><span class="line">&#x2F;&#x2F; 将int类型的原始值转换为reflect.Value类型</span><br><span class="line">c :&#x3D; reflect.ValueOf(10)</span><br><span class="line">fmt.Printf(&quot;type c :%T\n&quot;, c) &#x2F;&#x2F; type c :reflect.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a><font color=#ba3925 >通过反射设置变量的值</font></h5><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func reflectSetValue1(x interface&#123;&#125;) &#123;</span><br><span class="line">v :&#x3D; reflect.ValueOf(x)</span><br><span class="line">if v.Kind() &#x3D;&#x3D; reflect.Int64 &#123;</span><br><span class="line">v.SetInt(200) &#x2F;&#x2F;修改的是副本，reflect包会引发panic</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func reflectSetValue2(x interface&#123;&#125;) &#123;</span><br><span class="line">v :&#x3D; reflect.ValueOf(x)</span><br><span class="line">&#x2F;&#x2F; 反射中使用 Elem()方法获取指针对应的值</span><br><span class="line">if v.Elem().Kind() &#x3D;&#x3D; reflect.Int64 &#123;</span><br><span class="line">v.Elem().SetInt(200)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var a int64 &#x3D; 100</span><br><span class="line">&#x2F;&#x2F; reflectSetValue1(a) &#x2F;&#x2F;panic: reflect: reflect.Value.SetInt using unaddressable value</span><br><span class="line">reflectSetValue2(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isNil-和isValid"><a href="#isNil-和isValid" class="headerlink" title="isNil()和isValid()"></a><font color=#ba3925 >isNil()和isValid()</font></h4><h5 id="isNil"><a href="#isNil" class="headerlink" title="isNil()"></a><font color=#ba3925 >isNil()</font></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) IsNil() bool</span><br></pre></td></tr></table></figure><p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><h5 id="isValid"><a href="#isValid" class="headerlink" title="isValid()"></a><font color=#ba3925 >isValid()</font></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (v Value) IsValid() bool</span><br></pre></td></tr></table></figure><p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p><p>举个例子</p><p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; *int类型空指针</span><br><span class="line">var a *int</span><br><span class="line">fmt.Println(&quot;var a *int IsNil:&quot;, reflect.ValueOf(a).IsNil())</span><br><span class="line">&#x2F;&#x2F; nil值</span><br><span class="line">fmt.Println(&quot;nil IsValid:&quot;, reflect.ValueOf(nil).IsValid())</span><br><span class="line">&#x2F;&#x2F; 实例化一个匿名结构体</span><br><span class="line">b :&#x3D; struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 尝试从结构体中查找&quot;abc&quot;字段</span><br><span class="line">fmt.Println(&quot;不存在的结构体成员:&quot;, reflect.ValueOf(b).FieldByName(&quot;abc&quot;).IsValid())</span><br><span class="line">&#x2F;&#x2F; 尝试从结构体中查找&quot;abc&quot;方法</span><br><span class="line">fmt.Println(&quot;不存在的结构体方法:&quot;, reflect.ValueOf(b).MethodByName(&quot;abc&quot;).IsValid())</span><br><span class="line">&#x2F;&#x2F; map</span><br><span class="line">c :&#x3D; map[string]int&#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 尝试从map中查找一个不存在的键</span><br><span class="line">fmt.Println(&quot;map中不存在的键：&quot;, reflect.ValueOf(c).MapIndex(reflect.ValueOf(&quot;娜扎&quot;)).IsValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h3><h4 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a><font color=#ba3925 >与结构体相关的方法</font></h4><p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象<code>（reflect.Type）</code>的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p><p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Field(i int) StructField</td><td>根据索引，返回索引对应的结构体字段的信息。</td></tr><tr><td>NumField() int</td><td>返回结构体成员字段数量。</td></tr><tr><td>FieldByName(name string) (StructField, bool)</td><td>根据给定字符串返回字符串对应的结构体字段的信息。</td></tr><tr><td>FieldByIndex(index []int) StructField</td><td>多层成员访问时，根据 []int</td></tr><tr><td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td><td>根据传入的匹配函数匹配需要的字段。</td></tr><tr><td>NumMethod() int</td><td>返回该类型的方法集中方法的数目</td></tr><tr><td>Method(int) Method</td><td>返回该类型方法集中的第i个方法</td></tr><tr><td>MethodByName(string)(Method, bool)</td><td>根据方法名返回该类型方法集中的方法</td></tr></tbody></table><h4 id="StructField类型"><a href="#StructField类型" class="headerlink" title="StructField类型"></a><font color=#ba3925 >StructField类型</font></h4><p><code>StructField</code>类型用来描述结构体中的一个字段的信息。</p><p><code>StructField</code>的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type StructField struct &#123;</span><br><span class="line">    &#x2F;&#x2F; Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span><br><span class="line">    &#x2F;&#x2F; 参见http:&#x2F;&#x2F;golang.org&#x2F;ref&#x2F;spec#Uniqueness_of_identifiers</span><br><span class="line">    Name    string</span><br><span class="line">    PkgPath string</span><br><span class="line">    Type      Type      &#x2F;&#x2F; 字段的类型</span><br><span class="line">    Tag       StructTag &#x2F;&#x2F; 字段的标签</span><br><span class="line">    Offset    uintptr   &#x2F;&#x2F; 字段在结构体中的字节偏移量</span><br><span class="line">    Index     []int     &#x2F;&#x2F; 用于Type.FieldByIndex时的索引切片</span><br><span class="line">    Anonymous bool      &#x2F;&#x2F; 是否匿名字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StructField类型-1"><a href="#StructField类型-1" class="headerlink" title="StructField类型"></a><font color=#ba3925 >StructField类型</font></h4><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type student struct &#123;</span><br><span class="line">Name  string &#96;json:&quot;name&quot;&#96;</span><br><span class="line">Score int    &#96;json:&quot;score&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">stu1 :&#x3D; student&#123;</span><br><span class="line">Name:  &quot;小王子&quot;,</span><br><span class="line">Score: 90,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t :&#x3D; reflect.TypeOf(stu1)</span><br><span class="line">fmt.Println(t.Name(), t.Kind()) &#x2F;&#x2F; student struct</span><br><span class="line">&#x2F;&#x2F; 通过for循环遍历结构体的所有字段信息</span><br><span class="line">for i :&#x3D; 0; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">field :&#x3D; t.Field(i)</span><br><span class="line">fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, field.Name, field.Index, field.Type, field.Tag.Get(&quot;json&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过字段名获取指定结构体字段信息</span><br><span class="line">if scoreField, ok :&#x3D; t.FieldByName(&quot;Score&quot;); ok &#123;</span><br><span class="line">fmt.Printf(&quot;name:%s index:%d type:%v json tag:%v\n&quot;, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(&quot;json&quot;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写一个函数<code>printMethod(s interface&#123;&#125;)</code>来遍历打印s包含的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给student添加两个方法 Study和Sleep(注意首字母大写)</span><br><span class="line">func (s student) Study() string &#123;</span><br><span class="line">msg :&#x3D; &quot;好好学习，天天向上。&quot;</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">return msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s student) Sleep() string &#123;</span><br><span class="line">msg :&#x3D; &quot;好好睡觉，快快长大。&quot;</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">return msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printMethod(x interface&#123;&#125;) &#123;</span><br><span class="line">t :&#x3D; reflect.TypeOf(x)</span><br><span class="line">v :&#x3D; reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">fmt.Println(t.NumMethod())</span><br><span class="line">for i :&#x3D; 0; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">methodType :&#x3D; v.Method(i).Type()</span><br><span class="line">fmt.Printf(&quot;method name:%s\n&quot;, t.Method(i).Name)</span><br><span class="line">fmt.Printf(&quot;method:%s\n&quot;, methodType)</span><br><span class="line">&#x2F;&#x2F; 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span><br><span class="line">var args &#x3D; []reflect.Value&#123;&#125;</span><br><span class="line">v.Method(i).Call(args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="反射是把双刃剑"><a href="#反射是把双刃剑" class="headerlink" title="反射是把双刃剑"></a>反射是把双刃剑</h3><p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p><ol><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li><li>大量使用反射的代码通常难以理解。</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li></ol><hr><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>编写代码利用反射实现一个ini文件的解析器程序。</p>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口【GO语言基础】</title>
      <link href="2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/"/>
      <url>2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p><hr><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a><font color=#ba3925 >接口类型</font></h4><p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p><p><code>interface</code>是一组<code>method</code>的集合，是<code>duck-type programming</code>的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）。</p><p>为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。</p><h4 id="为什么要使用接口"><a href="#为什么要使用接口" class="headerlink" title="为什么要使用接口"></a><font color=#ba3925 >为什么要使用接口</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Cat struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c Cat) Say() string &#123; return &quot;喵喵喵&quot; &#125;</span><br><span class="line"></span><br><span class="line">type Dog struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (d Dog) Say() string &#123; return &quot;汪汪汪&quot; &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c :&#x3D; Cat&#123;&#125;</span><br><span class="line">fmt.Println(&quot;猫:&quot;, c.Say())</span><br><span class="line">d :&#x3D; Dog&#123;&#125;</span><br><span class="line">fmt.Println(&quot;狗:&quot;, d.Say())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？</p><p>像类似的例子在我们编程过程中会经常遇到：</p><p>比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？</p><p>比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？</p><p>比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？</p><p>Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。</p><h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a><font color=#ba3925 >接口的定义</font></h4><p>Go语言提倡面向接口编程。</p><p>每个接口由数个方法组成，接口的定义格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 接口类型名 interface&#123;</span><br><span class="line">    方法名1( 参数列表1 ) 返回值列表1</span><br><span class="line">    方法名2( 参数列表2 ) 返回值列表2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type writer interface&#123;</span><br><span class="line">    Write([]byte) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你看到这个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的Write方法来做一些事情。</p><h4 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a><font color=#ba3925 >实现接口的条件</font></h4><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个<strong>需要实现的方法列表</strong>。</p><p>我们来定义一个<code>Sayer</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Sayer 接口</span><br><span class="line">type Sayer interface &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>dog</code>和<code>cat</code>两个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type dog struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">type cat struct &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为<code>Sayer</code>接口里只有一个<code>say</code>方法，所以我们只需要给<code>dog</code>和<code>cat</code> 分别实现<code>say</code>方法就可以实现<code>Sayer</code>接口了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; dog实现了Sayer接口</span><br><span class="line">func (d dog) say() &#123;</span><br><span class="line">fmt.Println(&quot;汪汪汪&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; cat实现了Sayer接口</span><br><span class="line">func (c cat) say() &#123;</span><br><span class="line">fmt.Println(&quot;喵喵喵&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现就是这么简单，只要实现了接口中的所有方法，就实现了这个接口。</p><h4 id="接口类型变量"><a href="#接口类型变量" class="headerlink" title="接口类型变量"></a><font color=#ba3925 >接口类型变量</font></h4><p>那实现了接口有什么用呢？</p><p>接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，<code>Sayer</code>类型的变量能够存储<code>dog</code>和<code>cat</code>类型的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var x Sayer &#x2F;&#x2F; 声明一个Sayer类型的变量x</span><br><span class="line">a :&#x3D; cat&#123;&#125;  &#x2F;&#x2F; 实例化一个cat</span><br><span class="line">b :&#x3D; dog&#123;&#125;  &#x2F;&#x2F; 实例化一个dog</span><br><span class="line">x &#x3D; a       &#x2F;&#x2F; 可以把cat实例直接赋值给x</span><br><span class="line">x.say()     &#x2F;&#x2F; 喵喵喵</span><br><span class="line">x &#x3D; b       &#x2F;&#x2F; 可以把dog实例直接赋值给x</span><br><span class="line">x.say()     &#x2F;&#x2F; 汪汪汪</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a><font color=#ba3925 >值接收者和指针接收者实现接口的区别</font></h4><p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p><p>我们有一个<code>Mover</code>接口和一个<code>dog</code>结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Mover interface &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type dog struct &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a><font color=#ba3925 >值接收者实现接口</font></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (d dog) move() &#123;</span><br><span class="line">fmt.Println(&quot;狗会动&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现接口的是<code>dog</code>类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var x Mover</span><br><span class="line">var wangcai &#x3D; dog&#123;&#125; &#x2F;&#x2F; 旺财是dog类型</span><br><span class="line">x &#x3D; wangcai         &#x2F;&#x2F; x可以接收dog类型</span><br><span class="line">var fugui &#x3D; &amp;dog&#123;&#125;  &#x2F;&#x2F; 富贵是*dog类型</span><br><span class="line">x &#x3D; fugui           &#x2F;&#x2F; x可以接收*dog类型</span><br><span class="line">x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针*dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针<code>fugui</code>内部会自动求值<code>*fugui</code>。</p><h5 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a><font color=#ba3925 >指针接收者实现接口</font></h5><p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (d *dog) move() &#123;</span><br><span class="line">fmt.Println(&quot;狗会动&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var x Mover</span><br><span class="line">var wangcai &#x3D; dog&#123;&#125; &#x2F;&#x2F; 旺财是dog类型</span><br><span class="line">x &#x3D; wangcai         &#x2F;&#x2F; x不可以接收dog类型</span><br><span class="line">var fugui &#x3D; &amp;dog&#123;&#125;  &#x2F;&#x2F; 富贵是*dog类型</span><br><span class="line">x &#x3D; fugui           &#x2F;&#x2F; x可以接收*dog类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现<code>Mover</code>接口的是<code>*dog</code>类型，所以不能给<code>x</code>传入<code>dog</code>类型的wangcai，此时x只能存储<code>*dog</code>类型的值。</p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><font color=#ba3925 >面试题</font></h4><p><strong>注意：</strong> 这是一道你需要回答“能”或者“不能”的题！</p><p>首先请观察下面的这段代码，然后请回答这段代码能不能通过编译？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type People interface &#123;</span><br><span class="line">Speak(string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (stu *Student) Speak(think string) (talk string) &#123;</span><br><span class="line">if think &#x3D;&#x3D; &quot;sb&quot; &#123;</span><br><span class="line">talk &#x3D; &quot;你是个大帅比&quot;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">talk &#x3D; &quot;您好&quot;</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var peo People &#x3D; Student&#123;&#125;</span><br><span class="line">think :&#x3D; &quot;bitch&quot;</span><br><span class="line">fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a><font color=#ba3925 >类型与接口的关系</font></h4><h5 id="一个类型实现多个接口"><a href="#一个类型实现多个接口" class="headerlink" title="一个类型实现多个接口"></a><font color=#ba3925 >一个类型实现多个接口</font></h5><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。 例如，狗可以叫，也可以动。我们就分别定义Sayer接口和Mover接口，如下： <code>Mover</code>接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Sayer 接口</span><br><span class="line">type Sayer interface &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mover 接口</span><br><span class="line">type Mover interface &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dog既可以实现Sayer接口，也可以实现Mover接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type dog struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现Sayer接口</span><br><span class="line">func (d dog) say() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会叫汪汪汪\n&quot;, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现Mover接口</span><br><span class="line">func (d dog) move() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会动\n&quot;, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var x Sayer</span><br><span class="line">var y Mover</span><br><span class="line"></span><br><span class="line">var a &#x3D; dog&#123;name: &quot;旺财&quot;&#125;</span><br><span class="line">x &#x3D; a</span><br><span class="line">y &#x3D; a</span><br><span class="line">x.say()</span><br><span class="line">y.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多个类型实现同一接口"><a href="#多个类型实现同一接口" class="headerlink" title="多个类型实现同一接口"></a><font color=#ba3925 >多个类型实现同一接口</font></h5><p>Go语言中不同的类型还可以实现同一接口 首先我们定义一个<code>Mover</code>接口，它要求必须由一个<code>move</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Mover 接口</span><br><span class="line">type Mover interface &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如狗可以动，汽车也可以动，可以使用如下代码实现这个关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type dog struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type car struct &#123;</span><br><span class="line">brand string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; dog类型实现Mover接口</span><br><span class="line">func (d dog) move() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会跑\n&quot;, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; car类型实现Mover接口</span><br><span class="line">func (c car) move() &#123;</span><br><span class="line">fmt.Printf(&quot;%s速度70迈\n&quot;, c.brand)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们在代码中就可以把狗和汽车当成一个会动的物体来处理了，不再需要关注它们具体是什么，只需要调用它们的<code>move</code>方法就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var x Mover</span><br><span class="line">var a &#x3D; dog&#123;name: &quot;旺财&quot;&#125;</span><br><span class="line">var b &#x3D; car&#123;brand: &quot;保时捷&quot;&#125;</span><br><span class="line">x &#x3D; a</span><br><span class="line">x.move()</span><br><span class="line">x &#x3D; b</span><br><span class="line">x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">旺财会跑</span><br><span class="line">保时捷速度70迈</span><br></pre></td></tr></table></figure><p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; WashingMachine 洗衣机</span><br><span class="line">type WashingMachine interface &#123;</span><br><span class="line">wash()</span><br><span class="line">dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 甩干器</span><br><span class="line">type dryer struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现WashingMachine接口的dry()方法</span><br><span class="line">func (d dryer) dry() &#123;</span><br><span class="line">fmt.Println(&quot;甩一甩&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 海尔洗衣机</span><br><span class="line">type haier struct &#123;</span><br><span class="line">dryer &#x2F;&#x2F;嵌入甩干器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现WashingMachine接口的wash()方法</span><br><span class="line">func (h haier) wash() &#123;</span><br><span class="line">fmt.Println(&quot;洗刷刷&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a><font color=#ba3925 >接口嵌套</font></h4><p>接口与接口间可以通过嵌套创造出新的接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Sayer 接口</span><br><span class="line">type Sayer interface &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Mover 接口</span><br><span class="line">type Mover interface &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接口嵌套</span><br><span class="line">type animal interface &#123;</span><br><span class="line">Sayer</span><br><span class="line">Mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套得到的接口的使用与普通接口一样，这里我们让cat实现animal接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type cat struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c cat) say() &#123;</span><br><span class="line">fmt.Println(&quot;喵喵喵&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c cat) move() &#123;</span><br><span class="line">fmt.Println(&quot;猫会动&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var x animal</span><br><span class="line">x &#x3D; cat&#123;name: &quot;花花&quot;&#125;</span><br><span class="line">x.move()</span><br><span class="line">x.say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a><font color=#ba3925 >空接口</font></h4><h5 id="空接口的定义"><a href="#空接口的定义" class="headerlink" title="空接口的定义"></a><font color=#ba3925 >空接口的定义</font></h5><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p><p>空接口类型的变量可以存储任意类型的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 定义一个空接口x</span><br><span class="line">var x interface&#123;&#125;</span><br><span class="line">s :&#x3D; &quot;Hello 沙河&quot;</span><br><span class="line">x &#x3D; s</span><br><span class="line">fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</span><br><span class="line">i :&#x3D; 100</span><br><span class="line">x &#x3D; i</span><br><span class="line">fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</span><br><span class="line">b :&#x3D; true</span><br><span class="line">x &#x3D; b</span><br><span class="line">fmt.Printf(&quot;type:%T value:%v\n&quot;, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空接口的应用"><a href="#空接口的应用" class="headerlink" title="空接口的应用"></a><font color=#ba3925 >空接口的应用</font></h4><h5 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a><font color=#ba3925 >空接口作为函数的参数</font></h5><p>使用空接口实现可以接收任意类型的函数参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 空接口作为函数参数</span><br><span class="line">func show(a interface&#123;&#125;) &#123;</span><br><span class="line">fmt.Printf(&quot;type:%T value:%v\n&quot;, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="空接口作为map的值"><a href="#空接口作为map的值" class="headerlink" title="空接口作为map的值"></a><font color=#ba3925 >空接口作为map的值</font></h5><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 空接口作为map值</span><br><span class="line">var studentInfo &#x3D; make(map[string]interface&#123;&#125;)</span><br><span class="line">studentInfo[&quot;name&quot;] &#x3D; &quot;沙河娜扎&quot;</span><br><span class="line">studentInfo[&quot;age&quot;] &#x3D; 18</span><br><span class="line">studentInfo[&quot;married&quot;] &#x3D; false</span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a><font color=#ba3925 >类型断言</font></h4><p>空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？</p><h5 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a><font color=#ba3925 >接口值</font></h5><p>一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。</p><p>我们来看一个具体的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var w io.Writer</span><br><span class="line">w &#x3D; os.Stdout</span><br><span class="line">w &#x3D; new(bytes.Buffer)</span><br><span class="line">w &#x3D; nil</span><br></pre></td></tr></table></figure><p>请看下图分解：</p><p><img src="/img/2020-03-25/interface.png" alt="img"></p><p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>x：表示类型为interface{}的变量</li><li>T：表示断言x可能是的类型。<br>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var x interface&#123;&#125;</span><br><span class="line">x &#x3D; &quot;Hello 沙河&quot;</span><br><span class="line">v, ok :&#x3D; x.(string)</span><br><span class="line">if ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;类型断言失败&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中如果要断言多次就需要写多个<code>if</code>判断，这个时候我们可以使用<code>switch</code>语句来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func justifyType(x interface&#123;&#125;) &#123;</span><br><span class="line">switch v :&#x3D; x.(type) &#123;</span><br><span class="line">case string:</span><br><span class="line">fmt.Printf(&quot;x is a string，value is %v\n&quot;, v)</span><br><span class="line">case int:</span><br><span class="line">fmt.Printf(&quot;x is a int is %v\n&quot;, v)</span><br><span class="line">case bool:</span><br><span class="line">fmt.Printf(&quot;x is a bool is %v\n&quot;, v)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;unsupport type！&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。</p><p>关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p><hr><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>使用接口的方式实现一个既可以往终端写日志也可以往文件写日志的简易日志库。</p>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包【GO语言基础】</title>
      <link href="2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/"/>
      <url>2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。</p><hr><h3 id="Go语言的包（package）"><a href="#Go语言的包（package）" class="headerlink" title="Go语言的包（package）"></a>Go语言的包（package）</h3><h4 id="包介绍"><a href="#包介绍" class="headerlink" title="包介绍"></a><font color=#ba3925 >包介绍</font></h4><p><code>包（package）</code>是多个Go源码的集合，是一种高级的代码复用方案，Go语言为我们提供了很多内置包，如<code>fmt</code>、<code>os</code>、<code>io</code>等。</p><h4 id="定义包"><a href="#定义包" class="headerlink" title="定义包"></a><font color=#ba3925 >定义包</font></h4><p>我们还可以根据自己的需要创建自己的包。一个包可以简单理解为一个存放<code>.go</code>文件的文件夹。 该文件夹下面的所有go文件都要在代码的第一行添加如下代码，声明该文件归属的包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package 包名</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>一个文件夹下面直接包含的文件只能归属一个package，同样一个package的文件不能在多个文件夹下。</li><li>包名可以不和文件夹的名字一样，包名不能包含 - 符号。</li><li>包名为main的包为应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含main包的源代码则不会得到可执行文件。</li></ul><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a><font color=#ba3925 >可见性</font></h4><p>如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以让标识符对外可见了。</p><p>举个例子， 我们定义一个包名为pkg2的包，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package pkg2</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 包变量可见性</span><br><span class="line"></span><br><span class="line">var a &#x3D; 100 &#x2F;&#x2F; 首字母小写，外部包不可见，只能在当前包内使用</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首字母大写外部包可见，可在其他包中使用</span><br><span class="line">const Mode &#x3D; 1</span><br><span class="line"></span><br><span class="line">type person struct &#123; &#x2F;&#x2F; 首字母小写，外部包不可见，只能在当前包内使用</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首字母大写，外部包可见，可在其他包中使用</span><br><span class="line">func Add(x, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func age() &#123; &#x2F;&#x2F; 首字母小写，外部包不可见，只能在当前包内使用</span><br><span class="line">var Age &#x3D; 18 &#x2F;&#x2F; 函数局部变量，外部包不可见，只能在当前函数内使用</span><br><span class="line">fmt.Println(Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体中的字段名和接口中的方法名如果首字母都是大写，外部包可以访问这些字段和方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Student struct &#123;</span><br><span class="line">Name  string &#x2F;&#x2F;可在包外访问的方法</span><br><span class="line">class string &#x2F;&#x2F;仅限包内访问的字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Payer interface &#123;</span><br><span class="line">init() &#x2F;&#x2F;仅限包内访问的方法</span><br><span class="line">Pay()  &#x2F;&#x2F;可在包外访问的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a><font color=#ba3925 >包的导入</font></h4><p>要在代码中引用其他包的内容，需要使用import关键字导入使用的包。具体语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;包的路径&quot;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>import导入语句通常放在文件开头包声明语句的下面。</li><li>导入的包名需要使用双引号包裹起来。</li><li>包名是从$GOPATH/src/后开始计算的，使用/进行路径分隔。</li><li>Go语言中禁止循环导入包。</li></ul><h5 id="单行导入"><a href="#单行导入" class="headerlink" title="单行导入"></a><font color=#ba3925 >单行导入</font></h5><p>单行导入的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;包1&quot;</span><br><span class="line">import &quot;包2&quot;</span><br></pre></td></tr></table></figure><h5 id="多行导入"><a href="#多行导入" class="headerlink" title="多行导入"></a><font color=#ba3925 >多行导入</font></h5><p>多行导入的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;包1&quot;</span><br><span class="line">    &quot;包2&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="自定义包名"><a href="#自定义包名" class="headerlink" title="自定义包名"></a><font color=#ba3925 >自定义包名</font></h4><p>在导入包名的时候，我们还可以为导入的包设置别名。通常用于导入的包名太长或者导入的包名冲突的情况。具体语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 别名 &quot;包的路径&quot;</span><br></pre></td></tr></table></figure><p>单行导入方式定义别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import m &quot;github.com&#x2F;Q1mi&#x2F;studygo&#x2F;pkg_test&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(m.Add(100, 200))</span><br><span class="line">fmt.Println(m.Mode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多行导入方式定义别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    m &quot;github.com&#x2F;Q1mi&#x2F;studygo&#x2F;pkg_test&quot;</span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(m.Add(100, 200))</span><br><span class="line">fmt.Println(m.Mode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名导入包"><a href="#匿名导入包" class="headerlink" title="匿名导入包"></a><font color=#ba3925 >匿名导入包</font></h4><p>如果只希望导入包，而不使用包内部的数据时，可以使用匿名导入包。具体的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import _ &quot;包的路径&quot;</span><br></pre></td></tr></table></figure><p>匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。</p><h4 id="init-初始化函数"><a href="#init-初始化函数" class="headerlink" title="init()初始化函数"></a><font color=#ba3925 >init()初始化函数</font></h4><h5 id="init-函数介绍"><a href="#init-函数介绍" class="headerlink" title="init()函数介绍"></a><font color=#ba3925 >init()函数介绍</font></h5><p>在Go语言程序执行时导入包语句会自动触发包内部<code>init()</code>函数的调用。需要注意的是： <code>init()</code>函数没有参数也没有返回值。 <code>init()</code>函数在程序运行时自动被调用执行，不能在代码中主动调用它。</p><p>包初始化执行的顺序如下图所示：</p><p><img src="/img/2020-03-25/init01.png" alt="img"></p><p>init()函数执行顺序<br>Go语言包会从main包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</p><p>在运行时，被最后导入的包会最先初始化并调用其init()函数， 如下图示：</p><h5 id="init-函数执行顺序"><a href="#init-函数执行顺序" class="headerlink" title="init()函数执行顺序"></a><font color=#ba3925 >init()函数执行顺序</font></h5><p>Go语言包会从<code>main</code>包开始检查其导入的所有包，每个包中又可能导入了其他的包。Go编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。</p><p>在运行时，被最后导入的包会最先初始化并调用其<code>init()</code>函数， 如下图示：</p><p><img src="/img/2020-03-25/init02.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言结包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体【GO语言基础】</title>
      <link href="2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><hr><h3 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h3><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a><font color=#ba3925 >自定义类型</font></h4><p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将MyInt定义为int类型</span><br><span class="line">type MyInt int</span><br></pre></td></tr></table></figure><p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a><font color=#ba3925 >类型别名</font></h4><p>类型别名是<code>Go1.9</code>版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type TypeAlias &#x3D; Type</span><br></pre></td></tr></table></figure><p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type byte &#x3D; uint8</span><br><span class="line">type rune &#x3D; int32</span><br></pre></td></tr></table></figure><h4 id="类型定义和类型别名的区别"><a href="#类型定义和类型别名的区别" class="headerlink" title="类型定义和类型别名的区别"></a><font color=#ba3925 >类型定义和类型别名的区别</font></h4><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;类型定义</span><br><span class="line">type NewInt int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类型别名</span><br><span class="line">type MyInt &#x3D; int</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a NewInt</span><br><span class="line">var b MyInt</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;type of a:%T\n&quot;, a) &#x2F;&#x2F;type of a:main.NewInt</span><br><span class="line">fmt.Printf(&quot;type of b:%T\n&quot;, b) &#x2F;&#x2F;type of b:int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是<code>main.NewInt</code>，表示main包下定义的<code>NewInt</code>类型。b的类型是<code>int</code>。<code>MyInt</code>类型只会在代码中存在，编译完成时并不会有<code>MyInt</code>类型。</p><hr><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称<code>struct</code>。 也就是我们可以通过<code>struct</code>来定义自己的类型了。</p><p>Go语言中通过<code>struct</code>来实现面向对象。</p><h4 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a><font color=#ba3925 >结构体的定义</font></h4><p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 类型名 struct &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li><li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li><li>字段类型：表示结构体字段的具体类型。</li></ul><p>举个例子，我们定义一个<code>Person</code>（人）结构体，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">city string</span><br><span class="line">age  int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type person1 struct &#123;</span><br><span class="line">name, city string</span><br><span class="line">age        int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个<code>person</code>的自定义类型，它有<code>name</code>、<code>city</code>、<code>age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个<code>person</code>结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p><h4 id="结构体实例化"><a href="#结构体实例化" class="headerlink" title="结构体实例化"></a><font color=#ba3925 >结构体实例化</font></h4><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h5 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a><font color=#ba3925 >基本实例化</font></h5><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">city string</span><br><span class="line">age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var p1 person</span><br><span class="line">p1.name &#x3D; &quot;沙河娜扎&quot;</span><br><span class="line">p1.city &#x3D; &quot;北京&quot;</span><br><span class="line">p1.age &#x3D; 18</span><br><span class="line">fmt.Printf(&quot;p1&#x3D;%v\n&quot;, p1)  &#x2F;&#x2F;p1&#x3D;&#123;沙河娜扎 北京 18&#125;</span><br><span class="line">fmt.Printf(&quot;p1&#x3D;%#v\n&quot;, p1) &#x2F;&#x2F;p1&#x3D;main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:18&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过<code>.</code>来访问结构体的字段（成员变量）,例如<code>p1.name</code>和<code>p1.age</code>等。</p><h5 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a><font color=#ba3925 >匿名结构体</font></h5><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">     </span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">     </span><br><span class="line">func main() &#123;</span><br><span class="line">    var user struct&#123;Name string; Age int&#125;</span><br><span class="line">    user.Name &#x3D; &quot;小王子&quot;</span><br><span class="line">    user.Age &#x3D; 18</span><br><span class="line">    fmt.Printf(&quot;%#v\n&quot;, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a><font color=#ba3925 >创建指针类型结构体</font></h5><p>我们还可以通过使用<code>new</code>关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p2 &#x3D; new(person)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, p2)     &#x2F;&#x2F;*main.person</span><br><span class="line">fmt.Printf(&quot;p2&#x3D;%#v\n&quot;, p2) &#x2F;&#x2F;p2&#x3D;&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出<code>p2</code>是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p2 &#x3D; new(person)</span><br><span class="line">p2.name &#x3D; &quot;小王子&quot;</span><br><span class="line">p2.age &#x3D; 28</span><br><span class="line">p2.city &#x3D; &quot;上海&quot;</span><br><span class="line">fmt.Printf(&quot;p2&#x3D;%#v\n&quot;, p2) &#x2F;&#x2F;p2&#x3D;&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;上海&quot;, age:28&#125;</span><br></pre></td></tr></table></figure><h5 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a><font color=#ba3925 >取结构体的地址实例化</font></h5><p>使用<code>&amp;</code>对结构体进行取地址操作相当于对该结构体类型进行了一次<code>new</code>实例化操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 :&#x3D; &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, p3)     &#x2F;&#x2F;*main.person</span><br><span class="line">fmt.Printf(&quot;p3&#x3D;%#v\n&quot;, p3) &#x2F;&#x2F;p3&#x3D;&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br><span class="line">p3.name &#x3D; &quot;七米&quot;</span><br><span class="line">p3.age &#x3D; 30</span><br><span class="line">p3.city &#x3D; &quot;成都&quot;</span><br><span class="line">fmt.Printf(&quot;p3&#x3D;%#v\n&quot;, p3) &#x2F;&#x2F;p3&#x3D;&amp;main.person&#123;name:&quot;七米&quot;, city:&quot;成都&quot;, age:30&#125;</span><br></pre></td></tr></table></figure><p><code>p3.name = &quot;七米&quot;</code>其实在底层是<code>(*p3).name = &quot;七米&quot;</code>，这是Go语言帮我们实现的语法糖。</p><h5 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a><font color=#ba3925 >结构体初始化</font></h5><p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">name string</span><br><span class="line">city string</span><br><span class="line">age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var p4 person</span><br><span class="line">fmt.Printf(&quot;p4&#x3D;%#v\n&quot;, p4) &#x2F;&#x2F;p4&#x3D;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用键值对初始化"><a href="#使用键值对初始化" class="headerlink" title="使用键值对初始化"></a><font color=#ba3925 >使用键值对初始化</font></h5><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 :&#x3D; person&#123;</span><br><span class="line">name: &quot;小王子&quot;,</span><br><span class="line">city: &quot;北京&quot;,</span><br><span class="line">age:  18,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p5&#x3D;%#v\n&quot;, p5) &#x2F;&#x2F;p5&#x3D;main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 :&#x3D; &amp;person&#123;</span><br><span class="line">name: &quot;小王子&quot;,</span><br><span class="line">city: &quot;北京&quot;,</span><br><span class="line">age:  18,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p6&#x3D;%#v\n&quot;, p6) &#x2F;&#x2F;p6&#x3D;&amp;main.person&#123;name:&quot;小王子&quot;, city:&quot;北京&quot;, age:18&#125;</span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 :&#x3D; &amp;person&#123;</span><br><span class="line">city: &quot;北京&quot;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p7&#x3D;%#v\n&quot;, p7) &#x2F;&#x2F;p7&#x3D;&amp;main.person&#123;name:&quot;&quot;, city:&quot;北京&quot;, age:0&#125;</span><br></pre></td></tr></table></figure><h5 id="使用值的列表初始化"><a href="#使用值的列表初始化" class="headerlink" title="使用值的列表初始化"></a><font color=#ba3925 >使用值的列表初始化</font></h5><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 :&#x3D; &amp;person&#123;</span><br><span class="line">&quot;沙河娜扎&quot;,</span><br><span class="line">&quot;北京&quot;,</span><br><span class="line">28,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;p8&#x3D;%#v\n&quot;, p8) &#x2F;&#x2F;p8&#x3D;&amp;main.person&#123;name:&quot;沙河娜扎&quot;, city:&quot;北京&quot;, age:28&#125;</span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><ol><li>必须初始化结构体的所有字段。</li><li>初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li><li>该方式不能和键值初始化方式混用。</li></ol><h5 id="结构体内存布局"><a href="#结构体内存布局" class="headerlink" title="结构体内存布局"></a><font color=#ba3925 >结构体内存布局</font></h5><p>结构体占用一块连续的内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type test struct &#123;</span><br><span class="line">a int8</span><br><span class="line">b int8</span><br><span class="line">c int8</span><br><span class="line">d int8</span><br><span class="line">&#125;</span><br><span class="line">n :&#x3D; test&#123;</span><br><span class="line">1, 2, 3, 4,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;n.a %p\n&quot;, &amp;n.a)</span><br><span class="line">fmt.Printf(&quot;n.b %p\n&quot;, &amp;n.b)</span><br><span class="line">fmt.Printf(&quot;n.c %p\n&quot;, &amp;n.c)</span><br><span class="line">fmt.Printf(&quot;n.d %p\n&quot;, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure><p>【进阶知识点】关于Go语言中的内存对齐推荐阅读:在 Go 中恰到好处的内存对齐</p><h5 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a><font color=#ba3925 >空结构体</font></h5><p>空结构体是不占用空间的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v struct&#123;&#125;</span><br><span class="line">fmt.Println(unsafe.Sizeof(v))  &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure><hr><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><font color=#ba3925 >面试题</font></h4><p>请问下面代码的执行结果是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type student struct &#123;</span><br><span class="line">name string</span><br><span class="line">age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m :&#x3D; make(map[string]*student)</span><br><span class="line">stus :&#x3D; []student&#123;</span><br><span class="line">&#123;name: &quot;小王子&quot;, age: 18&#125;,</span><br><span class="line">&#123;name: &quot;娜扎&quot;, age: 23&#125;,</span><br><span class="line">&#123;name: &quot;大王八&quot;, age: 9000&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, stu :&#x3D; range stus &#123;</span><br><span class="line">m[stu.name] &#x3D; &amp;stu</span><br><span class="line">&#125;</span><br><span class="line">for k, v :&#x3D; range m &#123;</span><br><span class="line">fmt.Println(k, &quot;&#x3D;&gt;&quot;, v.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><font color=#ba3925 >构造函数</font></h4><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个<code>person</code>的构造函数。 因为<code>struct</code>是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func newPerson(name, city string, age int8) *person &#123;</span><br><span class="line">return &amp;person&#123;</span><br><span class="line">name: name,</span><br><span class="line">city: city,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 :&#x3D; newPerson(&quot;张三&quot;, &quot;沙河&quot;, 90)</span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, p9) &#x2F;&#x2F;&amp;main.person&#123;name:&quot;张三&quot;, city:&quot;沙河&quot;, age:90&#125;</span><br></pre></td></tr></table></figure><h4 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a><font color=#ba3925 >方法和接收者</font></h4><p>Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数。这种特定类型变量叫做<code>接收者（Receiver）</code>。接收者的概念就类似于其他语言中的<code>this</code>或者 <code>self</code>。</p><p>方法的定义格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Person 结构体</span><br><span class="line">type Person struct &#123;</span><br><span class="line">name string</span><br><span class="line">age  int8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;NewPerson 构造函数</span><br><span class="line">func NewPerson(name string, age int8) *Person &#123;</span><br><span class="line">return &amp;Person&#123;</span><br><span class="line">name: name,</span><br><span class="line">age:  age,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Dream Person做梦的方法</span><br><span class="line">func (p Person) Dream() &#123;</span><br><span class="line">fmt.Printf(&quot;%s的梦想是学好Go语言！\n&quot;, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">p1 :&#x3D; NewPerson(&quot;小王子&quot;, 25)</span><br><span class="line">p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h4 id="指针类型的接收者"><a href="#指针类型的接收者" class="headerlink" title="指针类型的接收者"></a><font color=#ba3925 >指针类型的接收者</font></h4><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的<code>this</code>或者<code>self</code>。 例如我们为<code>Person</code>添加一个<code>SetAge</code>方法，来修改实例变量的年龄。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SetAge 设置p的年龄</span><br><span class="line">&#x2F;&#x2F; 使用指针接收者</span><br><span class="line">func (p *Person) SetAge(newAge int8) &#123;</span><br><span class="line">p.age &#x3D; newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">p1 :&#x3D; NewPerson(&quot;小王子&quot;, 25)</span><br><span class="line">fmt.Println(p1.age) &#x2F;&#x2F; 25</span><br><span class="line">p1.SetAge(30)</span><br><span class="line">fmt.Println(p1.age) &#x2F;&#x2F; 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值类型的接收者"><a href="#值类型的接收者" class="headerlink" title="值类型的接收者"></a><font color=#ba3925 >值类型的接收者</font></h4><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SetAge2 设置p的年龄</span><br><span class="line">&#x2F;&#x2F; 使用值接收者</span><br><span class="line">func (p Person) SetAge2(newAge int8) &#123;</span><br><span class="line">p.age &#x3D; newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">p1 :&#x3D; NewPerson(&quot;小王子&quot;, 25)</span><br><span class="line">p1.Dream()</span><br><span class="line">fmt.Println(p1.age) &#x2F;&#x2F; 25</span><br><span class="line">p1.SetAge2(30) &#x2F;&#x2F; (*p1).SetAge2(30)</span><br><span class="line">fmt.Println(p1.age) &#x2F;&#x2F; 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么时候应该使用指针类型接收者"><a href="#什么时候应该使用指针类型接收者" class="headerlink" title="什么时候应该使用指针类型接收者"></a><font color=#ba3925 >什么时候应该使用指针类型接收者</font></h4><ol><li>需要修改接收者中的值</li><li>接收者是拷贝代价比较大的大对象</li><li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li></ol><h4 id="任意类型添加方法"><a href="#任意类型添加方法" class="headerlink" title="任意类型添加方法"></a><font color=#ba3925 >任意类型添加方法</font></h4><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的<code>int</code>类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MyInt 将int定义为自定义MyInt类型</span><br><span class="line">type MyInt int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;SayHello 为MyInt添加一个SayHello的方法</span><br><span class="line">func (m MyInt) SayHello() &#123;</span><br><span class="line">fmt.Println(&quot;Hello, 我是一个int。&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var m1 MyInt</span><br><span class="line">m1.SayHello() &#x2F;&#x2F;Hello, 我是一个int。</span><br><span class="line">m1 &#x3D; 100</span><br><span class="line">fmt.Printf(&quot;%#v  %T\n&quot;, m1, m1) &#x2F;&#x2F;100  main.MyInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong> 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h4 id="结构体的匿名字段"><a href="#结构体的匿名字段" class="headerlink" title="结构体的匿名字段"></a><font color=#ba3925 >结构体的匿名字段</font></h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Person 结构体Person类型</span><br><span class="line">type Person struct &#123;</span><br><span class="line">string</span><br><span class="line">int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">p1 :&#x3D; Person&#123;</span><br><span class="line">&quot;小王子&quot;,</span><br><span class="line">18,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, p1)        &#x2F;&#x2F;main.Person&#123;string:&quot;北京&quot;, int:18&#125;</span><br><span class="line">fmt.Println(p1.string, p1.int) &#x2F;&#x2F;北京 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h4 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a><font color=#ba3925 >嵌套结构体</font></h4><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Address 地址结构体</span><br><span class="line">type Address struct &#123;</span><br><span class="line">Province string</span><br><span class="line">City     string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;User 用户结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">Name    string</span><br><span class="line">Gender  string</span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">user1 :&#x3D; User&#123;</span><br><span class="line">Name:   &quot;小王子&quot;,</span><br><span class="line">Gender: &quot;男&quot;,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: &quot;山东&quot;,</span><br><span class="line">City:     &quot;威海&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;user1&#x3D;%#v\n&quot;, user1)&#x2F;&#x2F;user1&#x3D;main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套匿名结构体"><a href="#嵌套匿名结构体" class="headerlink" title="嵌套匿名结构体"></a><font color=#ba3925 >嵌套匿名结构体</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Address 地址结构体</span><br><span class="line">type Address struct &#123;</span><br><span class="line">Province string</span><br><span class="line">City     string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;User 用户结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">Name    string</span><br><span class="line">Gender  string</span><br><span class="line">Address &#x2F;&#x2F;匿名结构体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var user2 User</span><br><span class="line">user2.Name &#x3D; &quot;小王子&quot;</span><br><span class="line">user2.Gender &#x3D; &quot;男&quot;</span><br><span class="line">user2.Address.Province &#x3D; &quot;山东&quot;    &#x2F;&#x2F;通过匿名结构体.字段名访问</span><br><span class="line">user2.City &#x3D; &quot;威海&quot;                &#x2F;&#x2F;直接访问匿名结构体的字段名</span><br><span class="line">fmt.Printf(&quot;user2&#x3D;%#v\n&quot;, user2) &#x2F;&#x2F;user2&#x3D;main.User&#123;Name:&quot;小王子&quot;, Gender:&quot;男&quot;, Address:main.Address&#123;Province:&quot;山东&quot;, City:&quot;威海&quot;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p><h4 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a><font color=#ba3925 >嵌套结构体的字段名冲突</font></h4><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Address 地址结构体</span><br><span class="line">type Address struct &#123;</span><br><span class="line">Province   string</span><br><span class="line">City       string</span><br><span class="line">CreateTime string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Email 邮箱结构体</span><br><span class="line">type Email struct &#123;</span><br><span class="line">Account    string</span><br><span class="line">CreateTime string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;User 用户结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">Name   string</span><br><span class="line">Gender string</span><br><span class="line">Address</span><br><span class="line">Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var user3 User</span><br><span class="line">user3.Name &#x3D; &quot;沙河娜扎&quot;</span><br><span class="line">user3.Gender &#x3D; &quot;男&quot;</span><br><span class="line">&#x2F;&#x2F; user3.CreateTime &#x3D; &quot;2019&quot; &#x2F;&#x2F;ambiguous selector user3.CreateTime</span><br><span class="line">user3.Address.CreateTime &#x3D; &quot;2000&quot; &#x2F;&#x2F;指定Address结构体中的CreateTime</span><br><span class="line">user3.Email.CreateTime &#x3D; &quot;2000&quot;   &#x2F;&#x2F;指定Email结构体中的CreateTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体的“继承”"><a href="#结构体的“继承”" class="headerlink" title="结构体的“继承”"></a><font color=#ba3925 >结构体的“继承”</font></h4><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Animal 动物</span><br><span class="line">type Animal struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *Animal) move() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会动！\n&quot;, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Dog 狗</span><br><span class="line">type Dog struct &#123;</span><br><span class="line">Feet    int8</span><br><span class="line">*Animal &#x2F;&#x2F;通过嵌套匿名结构体实现继承</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d *Dog) wang() &#123;</span><br><span class="line">fmt.Printf(&quot;%s会汪汪汪~\n&quot;, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">d1 :&#x3D; &amp;Dog&#123;</span><br><span class="line">Feet: 4,</span><br><span class="line">Animal: &amp;Animal&#123; &#x2F;&#x2F;注意嵌套的是结构体指针</span><br><span class="line">name: &quot;乐乐&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang() &#x2F;&#x2F;乐乐会汪汪汪~</span><br><span class="line">d1.move() &#x2F;&#x2F;乐乐会动！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a><font color=#ba3925 >结构体字段的可见性</font></h4><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h4 id="结构体与JSON序列化"><a href="#结构体与JSON序列化" class="headerlink" title="结构体与JSON序列化"></a><font color=#ba3925 >结构体与JSON序列化</font></h4><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Student 学生</span><br><span class="line">type Student struct &#123;</span><br><span class="line">ID     int</span><br><span class="line">Gender string</span><br><span class="line">Name   string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Class 班级</span><br><span class="line">type Class struct &#123;</span><br><span class="line">Title    string</span><br><span class="line">Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c :&#x3D; &amp;Class&#123;</span><br><span class="line">Title:    &quot;101&quot;,</span><br><span class="line">Students: make([]*Student, 0, 200),</span><br><span class="line">&#125;</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">stu :&#x3D; &amp;Student&#123;</span><br><span class="line">Name:   fmt.Sprintf(&quot;stu%02d&quot;, i),</span><br><span class="line">Gender: &quot;男&quot;,</span><br><span class="line">ID:     i,</span><br><span class="line">&#125;</span><br><span class="line">c.Students &#x3D; append(c.Students, stu)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;JSON序列化：结构体--&gt;JSON格式的字符串</span><br><span class="line">data, err :&#x3D; json.Marshal(c)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;json marshal failed&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;json:%s\n&quot;, data)</span><br><span class="line">&#x2F;&#x2F;JSON反序列化：JSON格式的字符串--&gt;结构体</span><br><span class="line">str :&#x3D; &#96;&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;&#96;</span><br><span class="line">c1 :&#x3D; &amp;Class&#123;&#125;</span><br><span class="line">err &#x3D; json.Unmarshal([]byte(str), c1)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;json unmarshal failed!&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体标签（Tag）"><a href="#结构体标签（Tag）" class="headerlink" title="结构体标签（Tag）"></a><font color=#ba3925 >结构体标签（Tag）</font></h4><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;key1:&quot;value1&quot; key2:&quot;value2&quot;&#96;</span><br></pre></td></tr></table></figure><p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对标签（Tag），不同的键值对标签之间使用<strong>空格</strong>分隔。</p><p><strong>注意事项：</strong> 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p><p>例如我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Student 学生</span><br><span class="line">type Student struct &#123;</span><br><span class="line">ID     int    &#96;json:&quot;id&quot;&#96; &#x2F;&#x2F;通过指定tag实现json序列化该字段时的key</span><br><span class="line">Gender string &#x2F;&#x2F;json序列化是默认使用字段名作为key</span><br><span class="line">name   string &#x2F;&#x2F;私有不能被json包访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s1 :&#x3D; Student&#123;</span><br><span class="line">ID:     1,</span><br><span class="line">Gender: &quot;男&quot;,</span><br><span class="line">name:   &quot;沙河娜扎&quot;,</span><br><span class="line">&#125;</span><br><span class="line">data, err :&#x3D; json.Marshal(s1)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;json marshal failed!&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;json str:%s\n&quot;, data) &#x2F;&#x2F;json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体和方法补充知识点"><a href="#结构体和方法补充知识点" class="headerlink" title="结构体和方法补充知识点"></a><font color=#ba3925 >结构体和方法补充知识点</font></h4><p>因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。我们来看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">name   string</span><br><span class="line">age    int8</span><br><span class="line">dreams []string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) SetDreams(dreams []string) &#123;</span><br><span class="line">p.dreams &#x3D; dreams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">p1 :&#x3D; Person&#123;name: &quot;小王子&quot;, age: 18&#125;</span><br><span class="line">data :&#x3D; []string&#123;&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;&#125;</span><br><span class="line">p1.SetDreams(data)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 你真的想要修改 p1.dreams 吗？</span><br><span class="line">data[1] &#x3D; &quot;不睡觉&quot;</span><br><span class="line">fmt.Println(p1.dreams)  &#x2F;&#x2F; ?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (p *Person) SetDreams(dreams []string) &#123;</span><br><span class="line">p.dreams &#x3D; make([]string, len(dreams))</span><br><span class="line">copy(p.dreams, dreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。</p><hr><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>使用“面向对象”的思维方式编写一个学生信息管理系统。</p><ol><li>学生有id、姓名、年龄、分数等信息</li><li>程序提供展示学生列表、添加学生、编辑学生信息、删除学生等功能</li></ol>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言结构体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针【GO语言基础】</title>
      <link href="2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/"/>
      <url>2020/03/25/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p><p>要搞明白Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p><hr><h3 id="Go语言中的指针"><a href="#Go语言中的指针" class="headerlink" title="Go语言中的指针"></a>Go语言中的指针</h3><p>任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p><p>比如，“永远不要高估自己”这句话是我的座右铭，我想把它写入程序中，程序一启动这句话是要加载到内存（假设内存地址0x123456），我在程序中把这段话赋值给变量<code>A</code>，把内存地址赋值给变量<code>B</code>。这时候变量<code>B</code>就是一个指针变量。通过变量<code>A</code>和变量<code>B</code>都能找到我的座右铭。</p><p>Go语言中的指针不能进行偏移和运算，因此Go语言中的指针操作非常简单，我们只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p><h4 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a><font color=#ba3925 >指针地址和指针类型</font></h4><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用<code>&amp;</code>字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。</p><p>取变量指针的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr :&#x3D; &amp;v    &#x2F;&#x2F; v的类型为T</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>v:代表被取地址的变量，类型为T</li><li>ptr:用于接收地址的变量，ptr的类型就为<code>*T</code>，称做T的指针类型。<code>*</code>代表指针。</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; 10</span><br><span class="line">b :&#x3D; &amp;a</span><br><span class="line">fmt.Printf(&quot;a:%d ptr:%p\n&quot;, a, &amp;a) &#x2F;&#x2F; a:10 ptr:0xc00001a078</span><br><span class="line">fmt.Printf(&quot;b:%p type:%T\n&quot;, b, b) &#x2F;&#x2F; b:0xc00001a078 type:*int</span><br><span class="line">fmt.Println(&amp;b)                    &#x2F;&#x2F; 0xc00000e018</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下<code>b := &amp;a</code>的图示：取变量地址图示</p><p><img src="/img/2020-03-25/ptr.png" alt="img"></p><h4 id="指针取值"><a href="#指针取值" class="headerlink" title="指针取值"></a><font color=#ba3925 >指针取值</font></h4><p>在对普通变量使用&amp;操作符取地址后会获得这个变量的指针，然后可以对指针使用*操作，也就是指针取值，代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F;指针取值</span><br><span class="line">a :&#x3D; 10</span><br><span class="line">b :&#x3D; &amp;a &#x2F;&#x2F; 取变量a的地址，将指针保存到b中</span><br><span class="line">fmt.Printf(&quot;type of b:%T\n&quot;, b)</span><br><span class="line">c :&#x3D; *b &#x2F;&#x2F; 指针取值（根据指针去内存取值）</span><br><span class="line">fmt.Printf(&quot;type of c:%T\n&quot;, c)</span><br><span class="line">fmt.Printf(&quot;value of c:%v\n&quot;, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type of b:*int</span><br><span class="line">type of c:int</span><br><span class="line">value of c:10</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 取地址操作符<code>&amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p><p>变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：</p><ul><li>对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。</li><li>指针变量的值是指针地址。</li><li>对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。</li></ul><p><strong>指针传值示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func modify1(x int) &#123;</span><br><span class="line">x &#x3D; 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func modify2(x *int) &#123;</span><br><span class="line">*x &#x3D; 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; 10</span><br><span class="line">modify1(a)</span><br><span class="line">fmt.Println(a) &#x2F;&#x2F; 10</span><br><span class="line">modify2(&amp;a)</span><br><span class="line">fmt.Println(a) &#x2F;&#x2F; 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a><font color=#ba3925 >new和make</font></h4><p>我们先来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a *int</span><br><span class="line">*a &#x3D; 100</span><br><span class="line">fmt.Println(*a)</span><br><span class="line"></span><br><span class="line">var b map[string]int</span><br><span class="line">b[&quot;沙河娜扎&quot;] &#x3D; 100</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。</p><h5 id="new"><a href="#new" class="headerlink" title="new"></a><font color=#ba3925 >new</font></h5><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func new(Type) *Type</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li></ul><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; new(int)</span><br><span class="line">b :&#x3D; new(bool)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, a) &#x2F;&#x2F; *int</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, b) &#x2F;&#x2F; *bool</span><br><span class="line">fmt.Println(*a)       &#x2F;&#x2F; 0</span><br><span class="line">fmt.Println(*b)       &#x2F;&#x2F; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节开始的示例代码中<code>var a *int</code>只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a *int</span><br><span class="line">a &#x3D; new(int)</span><br><span class="line">*a &#x3D; 10</span><br><span class="line">fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="make"><a href="#make" class="headerlink" title="make"></a><font color=#ba3925 >make</font></h5><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func make(t Type, size ...IntegerType) Type</span><br></pre></td></tr></table></figure><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p><p>本节开始的示例中<code>var b map[string]</code>int只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var b map[string]int</span><br><span class="line">b &#x3D; make(map[string]int, 10)</span><br><span class="line">b[&quot;沙河娜扎&quot;] &#x3D; 100</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a><font color=#ba3925 >new与make的区别</font></h4><ol><li>二者都是用来做内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数【GO语言基础】</title>
      <link href="2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/"/>
      <url>2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。</p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>Go语言中定义函数使用<code>func</code>关键字，具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func 函数名(参数)(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。</li><li>参数：参数由参数变量和参数变量的类型组成，多个参数之间使用,分隔。</li><li>返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用()包裹，并用,分隔。</li><li>函数体：实现指定功能的代码块。</li></ul><p>我们先来定义一个求两个数之和的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func intSum(x int, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sayHello() &#123;</span><br><span class="line">fmt.Println(&quot;Hello 沙河&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h4><p>定义了函数之后，我们可以通过<code>函数名()</code>的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">sayHello()</span><br><span class="line">ret :&#x3D; intSum(10, 20)</span><br><span class="line">fmt.Println(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，调用有返回值的函数时，可以不接收其返回值。</p><hr><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="类型简写"><a href="#类型简写" class="headerlink" title="类型简写"></a>类型简写</h4><p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func intSum(x, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，<code>intSum</code>函数有两个参数，这两个参数的类型均为<code>int</code>，因此可以省略<code>x</code>的类型，因为<code>y</code>后面有类型说明，<code>x</code>参数也是该类型。</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p><p>注意：可变参数通常要作为函数的最后一个参数。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func intSum2(x ...int) int &#123;</span><br><span class="line">fmt.Println(x) &#x2F;&#x2F;x是一个切片</span><br><span class="line">sum :&#x3D; 0</span><br><span class="line">for _, v :&#x3D; range x &#123;</span><br><span class="line">sum &#x3D; sum + v</span><br><span class="line">&#125;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret1 :&#x3D; intSum2()</span><br><span class="line">ret2 :&#x3D; intSum2(10)</span><br><span class="line">ret3 :&#x3D; intSum2(10, 20)</span><br><span class="line">ret4 :&#x3D; intSum2(10, 20, 30)</span><br><span class="line">fmt.Println(ret1, ret2, ret3, ret4) &#x2F;&#x2F;0 10 30 60</span><br></pre></td></tr></table></figure><p>固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func intSum3(x int, y ...int) int &#123;</span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">sum :&#x3D; x</span><br><span class="line">for _, v :&#x3D; range y &#123;</span><br><span class="line">sum &#x3D; sum + v</span><br><span class="line">&#125;</span><br><span class="line">return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上述函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret5 :&#x3D; intSum3(100)</span><br><span class="line">ret6 :&#x3D; intSum3(100, 10)</span><br><span class="line">ret7 :&#x3D; intSum3(100, 10, 20)</span><br><span class="line">ret8 :&#x3D; intSum3(100, 10, 20, 30)</span><br><span class="line">fmt.Println(ret5, ret6, ret7, ret8) &#x2F;&#x2F;100 110 130 160</span><br></pre></td></tr></table></figure><p>本质上，函数的可变参数是通过切片来实现的。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>Go语言中通过<code>return</code>关键字向外输出返回值。</p><p>多返回值<br>Go语言中函数支持多返回值，函数如果有多个返回值时必须用<code>()</code>将所有返回值包裹起来。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func calc(x, y int) (int, int) &#123;</span><br><span class="line">sum :&#x3D; x + y</span><br><span class="line">sub :&#x3D; x - y</span><br><span class="line">return sum, sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回值命名"><a href="#返回值命名" class="headerlink" title="返回值命名"></a>返回值命名</h4><p>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<code>return</code>关键字返回。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func calc(x, y int) (sum, sub int) &#123;</span><br><span class="line">sum &#x3D; x + y</span><br><span class="line">sub &#x3D; x - y</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回值补充"><a href="#返回值补充" class="headerlink" title="返回值补充"></a>返回值补充</h4><p>当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func someFunc(x string) []int &#123;</span><br><span class="line">if x &#x3D;&#x3D; &quot;&quot; &#123;</span><br><span class="line">return nil &#x2F;&#x2F; 没必要返回[]int&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义全局变量num</span><br><span class="line">var num int64 &#x3D; 10</span><br><span class="line"></span><br><span class="line">func testGlobalVar() &#123;</span><br><span class="line">fmt.Printf(&quot;num&#x3D;%d\n&quot;, num) &#x2F;&#x2F;函数中可以访问全局变量num</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">testGlobalVar() &#x2F;&#x2F;num&#x3D;10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func testLocalVar() &#123;</span><br><span class="line">&#x2F;&#x2F;定义一个函数局部变量x,仅在该函数内生效</span><br><span class="line">var x int64 &#x3D; 100</span><br><span class="line">fmt.Printf(&quot;x&#x3D;%d\n&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">testLocalVar()</span><br><span class="line">fmt.Println(x) &#x2F;&#x2F; 此时无法使用变量x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果局部变量和全局变量重名，优先访问局部变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义全局变量num</span><br><span class="line">var num int64 &#x3D; 10</span><br><span class="line"></span><br><span class="line">func testNum() &#123;</span><br><span class="line">num :&#x3D; 100</span><br><span class="line">fmt.Printf(&quot;num&#x3D;%d\n&quot;, num) &#x2F;&#x2F; 函数中优先使用局部变量</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">testNum() &#x2F;&#x2F; num&#x3D;100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func testLocalVar2(x, y int) &#123;</span><br><span class="line">fmt.Println(x, y) &#x2F;&#x2F;函数的参数也是只在本函数中生效</span><br><span class="line">if x &gt; 0 &#123;</span><br><span class="line">z :&#x3D; 100 &#x2F;&#x2F;变量z只在if语句块生效</span><br><span class="line">fmt.Println(z)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;fmt.Println(z)&#x2F;&#x2F;此处无法使用变量z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func testLocalVar3() &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Println(i) &#x2F;&#x2F;变量i只在当前for语句块中生效</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;fmt.Println(i) &#x2F;&#x2F;此处无法使用变量i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数类型与变量"><a href="#函数类型与变量" class="headerlink" title="函数类型与变量"></a>函数类型与变量</h3><h4 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h4><p>我们可以使用<code>type</code>关键字来定义一个函数类型，具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type calculation func(int, int) int</span><br></pre></td></tr></table></figure><p>上面语句定义了一个<code>calculation</code>类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。</p><p>简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func add(x, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sub(x, y int) int &#123;</span><br><span class="line">return x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add和sub都能赋值给calculation类型的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var c calculation</span><br><span class="line">c &#x3D; add</span><br></pre></td></tr></table></figure><h4 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h4><p>我们可以声明函数类型的变量并且为该变量赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var c calculation               &#x2F;&#x2F; 声明一个calculation类型的变量c</span><br><span class="line">c &#x3D; add                         &#x2F;&#x2F; 把add赋值给c</span><br><span class="line">fmt.Printf(&quot;type of c:%T\n&quot;, c) &#x2F;&#x2F; type of c:main.calculation</span><br><span class="line">fmt.Println(c(1, 2))            &#x2F;&#x2F; 像调用add一样调用c</span><br><span class="line"></span><br><span class="line">f :&#x3D; add                        &#x2F;&#x2F; 将函数add赋值给变量f1</span><br><span class="line">fmt.Printf(&quot;type of f:%T\n&quot;, f) &#x2F;&#x2F; type of f:func(int, int) int</span><br><span class="line">fmt.Println(f(10, 20))          &#x2F;&#x2F; 像调用add一样调用f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数分为函数作为参数和函数作为返回值两部分。</p><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><p>函数可以作为参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func add(x, y int) int &#123;</span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br><span class="line">func calc(x, y int, op func(int, int) int) int &#123;</span><br><span class="line">return op(x, y)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">ret2 :&#x3D; calc(10, 20, add)</span><br><span class="line">fmt.Println(ret2) &#x2F;&#x2F;30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>函数也可以作为返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func do(s string) (func(int, int) int, error) &#123;</span><br><span class="line">switch s &#123;</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">return add, nil</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">return sub, nil</span><br><span class="line">default:</span><br><span class="line">err :&#x3D; errors.New(&quot;无法识别的操作符&quot;)</span><br><span class="line">return nil, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h3><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。匿名函数就是没有函数名的函数，匿名函数的定义格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(参数)(返回值)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 将匿名函数保存到变量</span><br><span class="line">add :&#x3D; func(x, y int) &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;</span><br><span class="line">add(10, 20) &#x2F;&#x2F; 通过变量调用匿名函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自执行函数：匿名函数定义完加()直接执行</span><br><span class="line">func(x, y int) &#123;</span><br><span class="line">fmt.Println(x + y)</span><br><span class="line">&#125;(10, 20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数多用于实现回调函数和闭包。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境。 首先我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func adder() func(int) int &#123;</span><br><span class="line">var x int</span><br><span class="line">return func(y int) int &#123;</span><br><span class="line">x +&#x3D; y</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var f &#x3D; adder()</span><br><span class="line">fmt.Println(f(10)) &#x2F;&#x2F;10</span><br><span class="line">fmt.Println(f(20)) &#x2F;&#x2F;30</span><br><span class="line">fmt.Println(f(30)) &#x2F;&#x2F;60</span><br><span class="line"></span><br><span class="line">f1 :&#x3D; adder()</span><br><span class="line">fmt.Println(f1(40)) &#x2F;&#x2F;40</span><br><span class="line">fmt.Println(f1(50)) &#x2F;&#x2F;90</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。 闭包进阶示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func adder2(x int) func(int) int &#123;</span><br><span class="line">return func(y int) int &#123;</span><br><span class="line">x +&#x3D; y</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var f &#x3D; adder2(10)</span><br><span class="line">fmt.Println(f(10)) &#x2F;&#x2F;20</span><br><span class="line">fmt.Println(f(20)) &#x2F;&#x2F;40</span><br><span class="line">fmt.Println(f(30)) &#x2F;&#x2F;70</span><br><span class="line"></span><br><span class="line">f1 :&#x3D; adder2(20)</span><br><span class="line">fmt.Println(f1(40)) &#x2F;&#x2F;60</span><br><span class="line">fmt.Println(f1(50)) &#x2F;&#x2F;110</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func makeSuffixFunc(suffix string) func(string) string &#123;</span><br><span class="line">return func(name string) string &#123;</span><br><span class="line">if !strings.HasSuffix(name, suffix) &#123;</span><br><span class="line">return name + suffix</span><br><span class="line">&#125;</span><br><span class="line">return name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">jpgFunc :&#x3D; makeSuffixFunc(&quot;.jpg&quot;)</span><br><span class="line">txtFunc :&#x3D; makeSuffixFunc(&quot;.txt&quot;)</span><br><span class="line">fmt.Println(jpgFunc(&quot;test&quot;)) &#x2F;&#x2F;test.jpg</span><br><span class="line">fmt.Println(txtFunc(&quot;test&quot;)) &#x2F;&#x2F;test.txt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包进阶示例3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func calc(base int) (func(int) int, func(int) int) &#123;</span><br><span class="line">add :&#x3D; func(i int) int &#123;</span><br><span class="line">base +&#x3D; i</span><br><span class="line">return base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub :&#x3D; func(i int) int &#123;</span><br><span class="line">base -&#x3D; i</span><br><span class="line">return base</span><br><span class="line">&#125;</span><br><span class="line">return add, sub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">f1, f2 :&#x3D; calc(10)</span><br><span class="line">fmt.Println(f1(1), f2(2)) &#x2F;&#x2F;11 9</span><br><span class="line">fmt.Println(f1(3), f2(4)) &#x2F;&#x2F;12 8</span><br><span class="line">fmt.Println(f1(5), f2(6)) &#x2F;&#x2F;13 7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包其实并不复杂，只要牢记<code>闭包=函数+引用环境</code>。</p><h3 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h3><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;start&quot;)</span><br><span class="line">defer fmt.Println(1)</span><br><span class="line">defer fmt.Println(2)</span><br><span class="line">defer fmt.Println(3)</span><br><span class="line">fmt.Println(&quot;end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p><h4 id="defer执行时机"><a href="#defer执行时机" class="headerlink" title="defer执行时机"></a>defer执行时机</h4><p>在Go语言的函数中<code>return</code>语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而<code>defer</code>语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：</p><p><img src="/img/2020-03-24/defer.png"></p><h4 id="defer经典案例"><a href="#defer经典案例" class="headerlink" title="defer经典案例"></a>defer经典案例</h4><p>阅读下面的代码，写出最后的打印结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func f1() int &#123;</span><br><span class="line">x :&#x3D; 5</span><br><span class="line">defer func() &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;()</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f2() (x int) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;()</span><br><span class="line">return 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f3() (y int) &#123;</span><br><span class="line">x :&#x3D; 5</span><br><span class="line">defer func() &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;()</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">func f4() (x int) &#123;</span><br><span class="line">defer func(x int) &#123;</span><br><span class="line">x++</span><br><span class="line">&#125;(x)</span><br><span class="line">return 5</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(f1())</span><br><span class="line">fmt.Println(f2())</span><br><span class="line">fmt.Println(f3())</span><br><span class="line">fmt.Println(f4())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="defer面试题"><a href="#defer面试题" class="headerlink" title="defer面试题"></a>defer面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">ret :&#x3D; a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">x :&#x3D; 1</span><br><span class="line">y :&#x3D; 2</span><br><span class="line">defer calc(&quot;AA&quot;, x, calc(&quot;A&quot;, x, y))</span><br><span class="line">x &#x3D; 10</span><br><span class="line">defer calc(&quot;BB&quot;, x, calc(&quot;B&quot;, x, y))</span><br><span class="line">y &#x3D; 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）</p><hr><h2 id="内置函数介绍"><a href="#内置函数介绍" class="headerlink" title="内置函数介绍"></a>内置函数介绍</h2><table><thead><tr><th>内置函数</th><th>介绍</th></tr></thead><tbody><tr><td>close</td><td>主要用来关闭channel</td></tr><tr><td>len</td><td>用来求长度，比如string、array、slice、map、channel</td></tr><tr><td>new</td><td>用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td></tr><tr><td>make</td><td>用来分配内存，主要用来分配引用类型，比如chan、map、slice</td></tr><tr><td>append</td><td>用来追加元素到数组、slice中</td></tr><tr><td>panic和recover</td><td>用来做错误处理</td></tr></tbody></table><h4 id="panic-recover"><a href="#panic-recover" class="headerlink" title="panic/recover"></a>panic/recover</h4><p>Go语言中目前（Go1.12）是没有异常机制，但是使用<code>panic/recover</code>模式来处理错误。 <code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效。 首先来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func funcA() &#123;</span><br><span class="line">fmt.Println(&quot;func A&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcB() &#123;</span><br><span class="line">panic(&quot;panic in B&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcC() &#123;</span><br><span class="line">fmt.Println(&quot;func C&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func A</span><br><span class="line">panic: panic in B</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.funcB(...)</span><br><span class="line">        ...&#x2F;code&#x2F;func&#x2F;main.go:12</span><br><span class="line">main.main()</span><br><span class="line">        ...&#x2F;code&#x2F;func&#x2F;main.go:20 +0x98</span><br></pre></td></tr></table></figure><p>程序运行期间<code>funcB</code>中引发了<code>panic</code>导致程序崩溃，异常退出了。这个时候我们就可以通过<code>recover</code>将程序恢复回来，继续往后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func funcA() &#123;</span><br><span class="line">fmt.Println(&quot;func A&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcB() &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">err :&#x3D; recover()</span><br><span class="line">&#x2F;&#x2F;如果程序出出现了panic错误,可以通过recover恢复过来</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;recover in B&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">panic(&quot;panic in B&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcC() &#123;</span><br><span class="line">fmt.Println(&quot;func C&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">funcA()</span><br><span class="line">funcB()</span><br><span class="line">funcC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>recover()必须搭配defer使用。</li><li>defer一定要在可能引发panic的语句之前定义。</li></ol><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1.分金币</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">你有50枚金币，需要分配给以下几个人：Matthew,Sarah,Augustus,Heidi,Emilie,Peter,Giana,Adriano,Aaron,Elizabeth。</span><br><span class="line">分配规则如下：</span><br><span class="line">a. 名字中每包含1个&#39;e&#39;或&#39;E&#39;分1枚金币</span><br><span class="line">b. 名字中每包含1个&#39;i&#39;或&#39;I&#39;分2枚金币</span><br><span class="line">c. 名字中每包含1个&#39;o&#39;或&#39;O&#39;分3枚金币</span><br><span class="line">d: 名字中每包含1个&#39;u&#39;或&#39;U&#39;分4枚金币</span><br><span class="line">写一个程序，计算每个用户分到多少金币，以及最后剩余多少金币？</span><br><span class="line">程序结构如下，请实现 ‘dispatchCoin’ 函数</span><br><span class="line">*&#x2F;</span><br><span class="line">var (</span><br><span class="line">coins &#x3D; 50</span><br><span class="line">users &#x3D; []string&#123;</span><br><span class="line">&quot;Matthew&quot;, &quot;Sarah&quot;, &quot;Augustus&quot;, &quot;Heidi&quot;, &quot;Emilie&quot;, &quot;Peter&quot;, &quot;Giana&quot;, &quot;Adriano&quot;, &quot;Aaron&quot;, &quot;Elizabeth&quot;,</span><br><span class="line">&#125;</span><br><span class="line">distribution &#x3D; make(map[string]int, len(users))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">left :&#x3D; dispatchCoin()</span><br><span class="line">fmt.Println(&quot;剩下：&quot;, left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map【GO语言基础】</title>
      <link href="2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/"/>
      <url>2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/</url>
      
        <content type="html"><![CDATA[<p>Go语言中提供的映射关系容器为<code>map</code>，其内部使用<code>散列表（hash）</code>实现。</p><hr><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map是一种无序的基于<code>key-value</code>的数据结构，Go语言中的map是引用类型，必须初始化才能使用。</p><h4 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h4><p>Go语言中 <code>map</code>的定义语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[KeyType]ValueType</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><p>map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make(map[KeyType]ValueType, [cap])</span><br></pre></td></tr></table></figure><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><h4 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h4><p>map中的数据都是成对出现的，map的基本使用示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">scoreMap :&#x3D; make(map[string]int, 8)</span><br><span class="line">scoreMap[&quot;张三&quot;] &#x3D; 90</span><br><span class="line">scoreMap[&quot;小明&quot;] &#x3D; 100</span><br><span class="line">fmt.Println(scoreMap)</span><br><span class="line">fmt.Println(scoreMap[&quot;小明&quot;])</span><br><span class="line">fmt.Printf(&quot;type of a:%T\n&quot;, scoreMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map[小明:100 张三:90]</span><br><span class="line">100</span><br><span class="line">type of a:map[string]int</span><br></pre></td></tr></table></figure><p>map也支持在声明的时候填充元素，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">userInfo :&#x3D; map[string]string&#123;</span><br><span class="line">&quot;username&quot;: &quot;沙河小王子&quot;,</span><br><span class="line">&quot;password&quot;: &quot;123456&quot;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(userInfo) &#x2F;&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h4><p>Go语言中有个判断map中键是否存在的特殊写法，格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok :&#x3D; map[key]</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">scoreMap :&#x3D; make(map[string]int)</span><br><span class="line">scoreMap[&quot;张三&quot;] &#x3D; 90</span><br><span class="line">scoreMap[&quot;小明&quot;] &#x3D; 100</span><br><span class="line">&#x2F;&#x2F; 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值</span><br><span class="line">v, ok :&#x3D; scoreMap[&quot;张三&quot;]</span><br><span class="line">if ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;查无此人&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h4><p>Go语言中使用<code>for range</code>遍历map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">scoreMap :&#x3D; make(map[string]int)</span><br><span class="line">scoreMap[&quot;张三&quot;] &#x3D; 90</span><br><span class="line">scoreMap[&quot;小明&quot;] &#x3D; 100</span><br><span class="line">scoreMap[&quot;娜扎&quot;] &#x3D; 60</span><br><span class="line">for k, v :&#x3D; range scoreMap &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们只想遍历key的时候，可以按下面的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">scoreMap :&#x3D; make(map[string]int)</span><br><span class="line">scoreMap[&quot;张三&quot;] &#x3D; 90</span><br><span class="line">scoreMap[&quot;小明&quot;] &#x3D; 100</span><br><span class="line">scoreMap[&quot;娜扎&quot;] &#x3D; 60</span><br><span class="line">for k :&#x3D; range scoreMap &#123;</span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p><h4 id="使用delete-函数删除键值对"><a href="#使用delete-函数删除键值对" class="headerlink" title="使用delete()函数删除键值对"></a>使用delete()函数删除键值对</h4><p>使用<code>delete()</code>内建函数从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(map, key)</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>map:表示要删除键值对的map</li><li>key:表示要删除的键值对的键</li></ul><p>示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">scoreMap :&#x3D; make(map[string]int)</span><br><span class="line">scoreMap[&quot;张三&quot;] &#x3D; 90</span><br><span class="line">scoreMap[&quot;小明&quot;] &#x3D; 100</span><br><span class="line">scoreMap[&quot;娜扎&quot;] &#x3D; 60</span><br><span class="line">delete(scoreMap, &quot;小明&quot;)&#x2F;&#x2F;将小明:100从map中删除</span><br><span class="line">for k,v :&#x3D; range scoreMap&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano()) &#x2F;&#x2F;初始化随机数种子</span><br><span class="line"></span><br><span class="line">var scoreMap &#x3D; make(map[string]int, 200)</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; 100; i++ &#123;</span><br><span class="line">key :&#x3D; fmt.Sprintf(&quot;stu%02d&quot;, i) &#x2F;&#x2F;生成stu开头的字符串</span><br><span class="line">value :&#x3D; rand.Intn(100)          &#x2F;&#x2F;生成0~99的随机整数</span><br><span class="line">scoreMap[key] &#x3D; value</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;取出map中的所有key存入切片keys</span><br><span class="line">var keys &#x3D; make([]string, 0, 200)</span><br><span class="line">for key :&#x3D; range scoreMap &#123;</span><br><span class="line">keys &#x3D; append(keys, key)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对切片进行排序</span><br><span class="line">sort.Strings(keys)</span><br><span class="line">&#x2F;&#x2F;按照排序后的key遍历map</span><br><span class="line">for _, key :&#x3D; range keys &#123;</span><br><span class="line">fmt.Println(key, scoreMap[key])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h4><p>下面的代码演示了切片中的元素为map类型时的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var mapSlice &#x3D; make([]map[string]string, 3)</span><br><span class="line">for index, value :&#x3D; range mapSlice &#123;</span><br><span class="line">fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;after init&quot;)</span><br><span class="line">&#x2F;&#x2F; 对切片中的map元素进行初始化</span><br><span class="line">mapSlice[0] &#x3D; make(map[string]string, 10)</span><br><span class="line">mapSlice[0][&quot;name&quot;] &#x3D; &quot;小王子&quot;</span><br><span class="line">mapSlice[0][&quot;password&quot;] &#x3D; &quot;123456&quot;</span><br><span class="line">mapSlice[0][&quot;address&quot;] &#x3D; &quot;沙河&quot;</span><br><span class="line">for index, value :&#x3D; range mapSlice &#123;</span><br><span class="line">fmt.Printf(&quot;index:%d value:%v\n&quot;, index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h4><p>下面的代码演示了map中值为切片类型的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var sliceMap &#x3D; make(map[string][]string, 3)</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">fmt.Println(&quot;after init&quot;)</span><br><span class="line">key :&#x3D; &quot;中国&quot;</span><br><span class="line">value, ok :&#x3D; sliceMap[key]</span><br><span class="line">if !ok &#123;</span><br><span class="line">value &#x3D; make([]string, 0, 2)</span><br><span class="line">&#125;</span><br><span class="line">value &#x3D; append(value, &quot;北京&quot;, &quot;上海&quot;)</span><br><span class="line">sliceMap[key] &#x3D; value</span><br><span class="line">fmt.Println(sliceMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li>写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do”中how=1 do=2 you=1。</li><li>观察下面代码，写出最终的打印结果。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">type Map map[string][]int</span><br><span class="line">m :&#x3D; make(Map)</span><br><span class="line">s :&#x3D; []int&#123;1, 2&#125;</span><br><span class="line">s &#x3D; append(s, 3)</span><br><span class="line">fmt.Printf(&quot;%+v\n&quot;, s)</span><br><span class="line">m[&quot;q1mi&quot;] &#x3D; s</span><br><span class="line">s &#x3D; append(s[:1], s[2:]...)</span><br><span class="line">fmt.Printf(&quot;%+v\n&quot;, s)</span><br><span class="line">fmt.Printf(&quot;%+v\n&quot;, m[&quot;q1mi&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片【GO语言基础】</title>
      <link href="2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/"/>
      <url>2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍Go语言中切片（slice）及它的基本使用。</p><hr><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func arraySum(x [3]int) int&#123;</span><br><span class="line">    sum :&#x3D; 0</span><br><span class="line">    for _, v :&#x3D; range x&#123;</span><br><span class="line">        sum &#x3D; sum + v</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a :&#x3D; [3]int&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。</p><h4 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h4><p>声明切片类型的基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name []T</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 声明切片类型</span><br><span class="line">var a []string              &#x2F;&#x2F;声明一个字符串切片</span><br><span class="line">var b &#x3D; []int&#123;&#125;             &#x2F;&#x2F;声明一个整型切片并初始化</span><br><span class="line">var c &#x3D; []bool&#123;false, true&#125; &#x2F;&#x2F;声明一个布尔切片并初始化</span><br><span class="line">var d &#x3D; []bool&#123;false, true&#125; &#x2F;&#x2F;声明一个布尔切片并初始化</span><br><span class="line">fmt.Println(a)              &#x2F;&#x2F;[]</span><br><span class="line">fmt.Println(b)              &#x2F;&#x2F;[]</span><br><span class="line">fmt.Println(c)              &#x2F;&#x2F;[false true]</span><br><span class="line">fmt.Println(a &#x3D;&#x3D; nil)       &#x2F;&#x2F;true</span><br><span class="line">fmt.Println(b &#x3D;&#x3D; nil)       &#x2F;&#x2F;false</span><br><span class="line">fmt.Println(c &#x3D;&#x3D; nil)       &#x2F;&#x2F;false</span><br><span class="line">&#x2F;&#x2F; fmt.Println(c &#x3D;&#x3D; d)   &#x2F;&#x2F;切片是引用类型，不支持直接比较，只能和nil比较</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h4><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p><h4 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h4><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><h4 id="简单切片表达式"><a href="#简单切片表达式" class="headerlink" title="简单切片表达式"></a>简单切片表达式</h4><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，又不包含），也就是下面代码中从数组a中选出<code>1&lt;=</code>索引值<code>&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">s :&#x3D; a[1:3]  &#x2F;&#x2F; s :&#x3D; a[low:high]</span><br><span class="line">fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:[2 3] len(s):2 cap(s):4</span><br></pre></td></tr></table></figure><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[2:]  &#x2F;&#x2F; 等同于 a[2:len(a)]</span><br><span class="line">a[:3]  &#x2F;&#x2F; 等同于 a[0:3]</span><br><span class="line">a[:]   &#x2F;&#x2F; 等同于 a[0:len(a)]</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p><p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">s :&#x3D; a[1:3]  &#x2F;&#x2F; s :&#x3D; a[low:high]</span><br><span class="line">fmt.Printf(&quot;s:%v len(s):%v cap(s):%v\n&quot;, s, len(s), cap(s))</span><br><span class="line">s2 :&#x3D; s[3:4]  &#x2F;&#x2F; 索引的上限是cap(s)而不是len(s)</span><br><span class="line">fmt.Printf(&quot;s2:%v len(s2):%v cap(s2):%v\n&quot;, s2, len(s2), cap(s2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s:[2 3] len(s):2 cap(s):4</span><br><span class="line">s2:[5] len(s2):1 cap(s2):1</span><br></pre></td></tr></table></figure><h4 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a>完整切片表达式</h4><p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high : max]</span><br></pre></td></tr></table></figure><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">t :&#x3D; a[1:3:5]</span><br><span class="line">fmt.Printf(&quot;t:%v len(t):%v cap(t):%v\n&quot;, t, len(t), cap(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t:[2 3] len(t):2 cap(t):4</span><br></pre></td></tr></table></figure><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p><h4 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h4><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make([]T, size, cap)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; make([]int, 2, 10)</span><br><span class="line">fmt.Println(a)      &#x2F;&#x2F;[0 0]</span><br><span class="line">fmt.Println(len(a)) &#x2F;&#x2F;2</span><br><span class="line">fmt.Println(cap(a)) &#x2F;&#x2F;10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h4 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h4><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>举个例子，现在有一个数组<code>a := [8]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。</p><p><img src="/img/2020-03-24/slice_01.png"></p><p>切片s2 := a[3:6]，相应示意图如下：</p><p><img src="/img/2020-03-24/slice_02.png"></p><h4 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h4><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h4 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h4><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s1 []int         &#x2F;&#x2F;len(s1)&#x3D;0;cap(s1)&#x3D;0;s1&#x3D;&#x3D;nil</span><br><span class="line">s2 :&#x3D; []int&#123;&#125;        &#x2F;&#x2F;len(s2)&#x3D;0;cap(s2)&#x3D;0;s2!&#x3D;nil</span><br><span class="line">s3 :&#x3D; make([]int, 0) &#x2F;&#x2F;len(s3)&#x3D;0;cap(s3)&#x3D;0;s3!&#x3D;nil</span><br></pre></td></tr></table></figure><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h4 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h4><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">s1 :&#x3D; make([]int, 3) &#x2F;&#x2F;[0 0 0]</span><br><span class="line">s2 :&#x3D; s1             &#x2F;&#x2F;将s1直接赋值给s2，s1和s2共用一个底层数组</span><br><span class="line">s2[0] &#x3D; 100</span><br><span class="line">fmt.Println(s1) &#x2F;&#x2F;[100 0 0]</span><br><span class="line">fmt.Println(s2) &#x2F;&#x2F;[100 0 0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h4><p>切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">s :&#x3D; []int&#123;1, 3, 5&#125;</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; len(s); i++ &#123;</span><br><span class="line">fmt.Println(i, s[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for index, value :&#x3D; range s &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h4><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">var s []int</span><br><span class="line">s &#x3D; append(s, 1)        &#x2F;&#x2F; [1]</span><br><span class="line">s &#x3D; append(s, 2, 3, 4)  &#x2F;&#x2F; [1 2 3 4]</span><br><span class="line">s2 :&#x3D; []int&#123;5, 6, 7&#125;  </span><br><span class="line">s &#x3D; append(s, s2...)    &#x2F;&#x2F; [1 2 3 4 5 6 7]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s []int</span><br><span class="line">s &#x3D; append(s, 1, 2, 3)</span><br></pre></td></tr></table></figure><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s :&#x3D; []int&#123;&#125;  &#x2F;&#x2F; 没有必要初始化</span><br><span class="line">s &#x3D; append(s, 1, 2, 3)</span><br><span class="line"></span><br><span class="line">var s &#x3D; make([]int)  &#x2F;&#x2F; 没有必要初始化</span><br><span class="line">s &#x3D; append(s, 1, 2, 3)</span><br></pre></td></tr></table></figure><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F;append()添加元素和切片扩容</span><br><span class="line">var numSlice []int</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">numSlice &#x3D; append(numSlice, i)</span><br><span class="line">fmt.Printf(&quot;%v  len:%d  cap:%d  ptr:%p\n&quot;, numSlice, len(numSlice), cap(numSlice), numSlice)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0]  len:1  cap:1  ptr:0xc0000a8000</span><br><span class="line">[0 1]  len:2  cap:2  ptr:0xc0000a8040</span><br><span class="line">[0 1 2]  len:3  cap:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020</span><br><span class="line">[0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000</span><br><span class="line">[0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var citySlice []string</span><br><span class="line">&#x2F;&#x2F; 追加一个元素</span><br><span class="line">citySlice &#x3D; append(citySlice, &quot;北京&quot;)</span><br><span class="line">&#x2F;&#x2F; 追加多个元素</span><br><span class="line">citySlice &#x3D; append(citySlice, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;)</span><br><span class="line">&#x2F;&#x2F; 追加切片</span><br><span class="line">a :&#x3D; []string&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;</span><br><span class="line">citySlice &#x3D; append(citySlice, a...)</span><br><span class="line">fmt.Println(citySlice) &#x2F;&#x2F;[北京 上海 广州 深圳 成都 重庆]</span><br></pre></td></tr></table></figure><h4 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h4><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">newcap :&#x3D; old.cap</span><br><span class="line">doublecap :&#x3D; newcap + newcap</span><br><span class="line">if cap &gt; doublecap &#123;</span><br><span class="line">newcap &#x3D; cap</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if old.len &lt; 1024 &#123;</span><br><span class="line">newcap &#x3D; doublecap</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; Check 0 &lt; newcap to detect overflow</span><br><span class="line">&#x2F;&#x2F; and prevent an infinite loop.</span><br><span class="line">for 0 &lt; newcap &amp;&amp; newcap &lt; cap &#123;</span><br><span class="line">newcap +&#x3D; newcap &#x2F; 4</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Set newcap to the requested cap when</span><br><span class="line">&#x2F;&#x2F; the newcap calculation overflowed.</span><br><span class="line">if newcap &lt;&#x3D; 0 &#123;</span><br><span class="line">newcap &#x3D; cap</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</p><h4 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h4><p>首先我们来看一个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">b :&#x3D; a</span><br><span class="line">fmt.Println(a) &#x2F;&#x2F;[1 2 3 4 5]</span><br><span class="line">fmt.Println(b) &#x2F;&#x2F;[1 2 3 4 5]</span><br><span class="line">b[0] &#x3D; 1000</span><br><span class="line">fmt.Println(a) &#x2F;&#x2F;[1000 2 3 4 5]</span><br><span class="line">fmt.Println(b) &#x2F;&#x2F;[1000 2 3 4 5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(destSlice, srcSlice []T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; copy()复制切片</span><br><span class="line">a :&#x3D; []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">c :&#x3D; make([]int, 5, 5)</span><br><span class="line">copy(c, a)     &#x2F;&#x2F;使用copy()函数将切片a中的元素复制到切片c</span><br><span class="line">fmt.Println(a) &#x2F;&#x2F;[1 2 3 4 5]</span><br><span class="line">fmt.Println(c) &#x2F;&#x2F;[1 2 3 4 5]</span><br><span class="line">c[0] &#x3D; 1000</span><br><span class="line">fmt.Println(a) &#x2F;&#x2F;[1 2 3 4 5]</span><br><span class="line">fmt.Println(c) &#x2F;&#x2F;[1000 2 3 4 5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h4><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 从切片中删除元素</span><br><span class="line">a :&#x3D; []int&#123;30, 31, 32, 33, 34, 35, 36, 37&#125;</span><br><span class="line">&#x2F;&#x2F; 要删除索引为2的元素</span><br><span class="line">a &#x3D; append(a[:2], a[3:]...)</span><br><span class="line">fmt.Println(a) &#x2F;&#x2F;[30 31 33 34 35 36 37]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><p>1.请写出下面代码的输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a &#x3D; make([]string, 5, 10)</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">a &#x3D; append(a, fmt.Sprintf(&quot;%v&quot;, i))</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.请使用内置的<code>sort</code>包对数组<code>var a = [...]int&#123;3, 7, 8, 9, 1&#125;</code>进行排序</p>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言切片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组【GO语言基础】</title>
      <link href="2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
      <url>2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍Go语言中数组（array）及它的基本使用。</p><hr><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h3><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个长度为3元素类型为int的数组a</span><br><span class="line">var a [3]int</span><br></pre></td></tr></table></figure><h4 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 数组变量名 [元素数量]T</span><br></pre></td></tr></table></figure><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a [3]int</span><br><span class="line">var b [4]int</span><br><span class="line">a &#x3D; b &#x2F;&#x2F;不可以这样做，因为此时a和b是不同的类型</span><br></pre></td></tr></table></figure><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h4 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h4><p>数组的初始化也有很多方式。</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var testArray [3]int                        &#x2F;&#x2F;数组会初始化为int类型的零值</span><br><span class="line">var numArray &#x3D; [3]int&#123;1, 2&#125;                 &#x2F;&#x2F;使用指定的初始值完成初始化</span><br><span class="line">var cityArray &#x3D; [3]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125; &#x2F;&#x2F;使用指定的初始值完成初始化</span><br><span class="line">fmt.Println(testArray)                      &#x2F;&#x2F;[0 0 0]</span><br><span class="line">fmt.Println(numArray)                       &#x2F;&#x2F;[1 2 0]</span><br><span class="line">fmt.Println(cityArray)                      &#x2F;&#x2F;[北京 上海 深圳]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var testArray [3]int</span><br><span class="line">var numArray &#x3D; [...]int&#123;1, 2&#125;</span><br><span class="line">var cityArray &#x3D; [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line">fmt.Println(testArray)                          &#x2F;&#x2F;[0 0 0]</span><br><span class="line">fmt.Println(numArray)                           &#x2F;&#x2F;[1 2]</span><br><span class="line">fmt.Printf(&quot;type of numArray:%T\n&quot;, numArray)   &#x2F;&#x2F;type of numArray:[2]int</span><br><span class="line">fmt.Println(cityArray)                          &#x2F;&#x2F;[北京 上海 深圳]</span><br><span class="line">fmt.Printf(&quot;type of cityArray:%T\n&quot;, cityArray) &#x2F;&#x2F;type of cityArray:[3]string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [...]int&#123;1: 1, 3: 5&#125;</span><br><span class="line">fmt.Println(a)                  &#x2F;&#x2F; [0 1 0 5]</span><br><span class="line">fmt.Printf(&quot;type of a:%T\n&quot;, a) &#x2F;&#x2F;type of a:[4]int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><p>遍历数组a有以下两种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a &#x3D; [...]string&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; 方法1：for循环遍历</span><br><span class="line">for i :&#x3D; 0; i &lt; len(a); i++ &#123;</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法2：for range遍历</span><br><span class="line">for index, value :&#x3D; range a &#123;</span><br><span class="line">fmt.Println(index, value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。</p><h4 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [3][2]string&#123;</span><br><span class="line">&#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">&#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a) &#x2F;&#x2F;[[北京 上海] [广州 深圳] [成都 重庆]]</span><br><span class="line">fmt.Println(a[2][1]) &#x2F;&#x2F;支持索引取值:重庆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [3][2]string&#123;</span><br><span class="line">&#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">&#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">for _, v1 :&#x3D; range a &#123;</span><br><span class="line">for _, v2 :&#x3D; range v1 &#123;</span><br><span class="line">fmt.Printf(&quot;%s\t&quot;, v2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">北京上海</span><br><span class="line">广州深圳</span><br><span class="line">成都重庆</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;支持的写法</span><br><span class="line">a :&#x3D; [...][2]string&#123;</span><br><span class="line">&#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">&#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;不支持多维数组的内层使用...</span><br><span class="line">b :&#x3D; [3][...]string&#123;</span><br><span class="line">&#123;&quot;北京&quot;, &quot;上海&quot;&#125;,</span><br><span class="line">&#123;&quot;广州&quot;, &quot;深圳&quot;&#125;,</span><br><span class="line">&#123;&quot;成都&quot;, &quot;重庆&quot;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h4><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func modifyArray(x [3]int) &#123;</span><br><span class="line">x[0] &#x3D; 100</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func modifyArray2(x [3][2]int) &#123;</span><br><span class="line">x[2][0] &#x3D; 100</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">a :&#x3D; [3]int&#123;10, 20, 30&#125;</span><br><span class="line">modifyArray(a) &#x2F;&#x2F;在modify中修改的是a的副本x</span><br><span class="line">fmt.Println(a) &#x2F;&#x2F;[10 20 30]</span><br><span class="line">b :&#x3D; [3][2]int&#123;</span><br><span class="line">&#123;1, 1&#125;,</span><br><span class="line">&#123;1, 1&#125;,</span><br><span class="line">&#123;1, 1&#125;,</span><br><span class="line">&#125;</span><br><span class="line">modifyArray2(b) &#x2F;&#x2F;在modify中修改的是b的副本x</span><br><span class="line">fmt.Println(b)  &#x2F;&#x2F;[[1 1] [1 1] [1 1]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 。</li></ol>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程控制【GO语言基础】</title>
      <link href="2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p><p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。</p><hr><h3 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else(分支结构)"></a>if else(分支结构)</h3><h4 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h4><p>Go语言中<code>if</code>条件判断的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 表达式1 &#123;</span><br><span class="line">    分支1</span><br><span class="line">&#125; else if 表达式2 &#123;</span><br><span class="line">    分支2</span><br><span class="line">&#125; else&#123;</span><br><span class="line">    分支3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</p><p>Go语言规定与<code>if</code>匹配的左括号<code>&#123;</code>必须与<code>if</code>和表达式放在同一行，<code>&#123;</code>放在其他位置会触发编译错误。同理，与<code>else</code>匹配的<code>&#123;</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func ifDemo1() &#123;</span><br><span class="line">score :&#x3D; 65</span><br><span class="line">if score &gt;&#x3D; 90 &#123;</span><br><span class="line">fmt.Println(&quot;A&quot;)</span><br><span class="line">&#125; else if score &gt; 75 &#123;</span><br><span class="line">fmt.Println(&quot;B&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;C&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h4><p>if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func ifDemo2() &#123;</span><br><span class="line">if score :&#x3D; 65; score &gt;&#x3D; 90 &#123;</span><br><span class="line">fmt.Println(&quot;A&quot;)</span><br><span class="line">&#125; else if score &gt; 75 &#123;</span><br><span class="line">fmt.Println(&quot;B&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;C&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 上下两种写法的区别在于作用域的不同，后者限定了变量 score 的使用只能在 if 结构体内</p><h4 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for(循环结构)"></a>for(循环结构)</h4><p>Go 语言中的所有循环类型均可以使用<code>for</code>关键字来完成。</p><p>for循环的基本格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式返回true时循环体不停地进行循环，直到条件表达式返回false时自动退出循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func forDemo() &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func forDemo2() &#123;</span><br><span class="line">i :&#x3D; 0</span><br><span class="line">for ; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环的初始语句和结束语句都可以省略，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func forDemo3() &#123;</span><br><span class="line">i :&#x3D; 0</span><br><span class="line">for i &lt; 10 &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环可以通过break、goto、return、panic语句强制退出循环。</p><h4 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range(键值循环)"></a>for range(键值循环)</h4><p>Go语言中可以使用<code>for range</code>遍历数组、切片、字符串、map 及通道（channel）。 通过<code>for range</code>遍历的返回值有以下规律：</p><ol><li>数组、切片、字符串返回索引和值。</li><li>map返回键和值。</li><li>通道（channel）只返回通道内的值。</li></ol><h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h4><p>使用switch语句可方便地对大量的值进行条件判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func switchDemo1() &#123;</span><br><span class="line">finger :&#x3D; 3</span><br><span class="line">switch finger &#123;</span><br><span class="line">case 1:</span><br><span class="line">fmt.Println(&quot;大拇指&quot;)</span><br><span class="line">case 2:</span><br><span class="line">fmt.Println(&quot;食指&quot;)</span><br><span class="line">case 3:</span><br><span class="line">fmt.Println(&quot;中指&quot;)</span><br><span class="line">case 4:</span><br><span class="line">fmt.Println(&quot;无名指&quot;)</span><br><span class="line">case 5:</span><br><span class="line">fmt.Println(&quot;小拇指&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;无效的输入！&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p><p>一个分支可以有多个值，多个case值中间使用英文逗号分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func testSwitch3() &#123;</span><br><span class="line">switch n :&#x3D; 7; n &#123;</span><br><span class="line">case 1, 3, 5, 7, 9:</span><br><span class="line">fmt.Println(&quot;奇数&quot;)</span><br><span class="line">case 2, 4, 6, 8:</span><br><span class="line">fmt.Println(&quot;偶数&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支还可以使用表达式，这时候<code>switch</code>语句后面不需要再跟判断变量。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func switchDemo4() &#123;</span><br><span class="line">age :&#x3D; 30</span><br><span class="line">switch &#123;</span><br><span class="line">case age &lt; 25:</span><br><span class="line">fmt.Println(&quot;好好学习吧&quot;)</span><br><span class="line">case age &gt; 25 &amp;&amp; age &lt; 35:</span><br><span class="line">fmt.Println(&quot;好好工作吧&quot;)</span><br><span class="line">case age &gt; 60:</span><br><span class="line">fmt.Println(&quot;好好享受吧&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;活着真好&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fallthrough</code>语法可以执行满足条件的case的下一个case，是为了兼容C语言中的case设计的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func switchDemo5() &#123;</span><br><span class="line">s :&#x3D; &quot;a&quot;</span><br><span class="line">switch &#123;</span><br><span class="line">case s &#x3D;&#x3D; &quot;a&quot;:</span><br><span class="line">fmt.Println(&quot;a&quot;)</span><br><span class="line">fallthrough</span><br><span class="line">case s &#x3D;&#x3D; &quot;b&quot;:</span><br><span class="line">fmt.Println(&quot;b&quot;)</span><br><span class="line">case s &#x3D;&#x3D; &quot;c&quot;:</span><br><span class="line">fmt.Println(&quot;c&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;...&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h4 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto(跳转到指定标签)"></a>goto(跳转到指定标签)</h4><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的<code>for</code>循环要退出时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func gotoDemo1() &#123;</span><br><span class="line">var breakFlag bool</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">for j :&#x3D; 0; j &lt; 10; j++ &#123;</span><br><span class="line">if j &#x3D;&#x3D; 2 &#123;</span><br><span class="line">&#x2F;&#x2F; 设置退出标签</span><br><span class="line">breakFlag &#x3D; true</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%v-%v\n&quot;, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 外层for循环判断</span><br><span class="line">if breakFlag &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>goto</code>语句能简化代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func gotoDemo2() &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">for j :&#x3D; 0; j &lt; 10; j++ &#123;</span><br><span class="line">if j &#x3D;&#x3D; 2 &#123;</span><br><span class="line">&#x2F;&#x2F; 设置退出标签</span><br><span class="line">goto breakTag</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%v-%v\n&quot;, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#x2F;&#x2F; 标签</span><br><span class="line">breakTag:</span><br><span class="line">fmt.Println(&quot;结束for循环&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break(跳出循环)"></a>break(跳出循环)</h4><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p><p><code>break</code>语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 </p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func breakDemo1() &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">for j :&#x3D; 0; j &lt; 10; j++ &#123;</span><br><span class="line">if j &#x3D;&#x3D; 2 &#123;</span><br><span class="line">break BREAKDEMO1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%v-%v\n&quot;, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue(继续下次循环)"></a>continue(继续下次循环)</h4><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p><p>在 <code>continue</code>语句后添加标签时，表示开始标签对应的循环。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func continueDemo() &#123;</span><br><span class="line">forloop1:</span><br><span class="line">for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">&#x2F;&#x2F; forloop2:</span><br><span class="line">for j :&#x3D; 0; j &lt; 5; j++ &#123;</span><br><span class="line">if i &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 2 &#123;</span><br><span class="line">continue forloop1</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%v-%v\n&quot;, i, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言流程控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符【GO语言基础】</title>
      <link href="2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>运算符用于在程序运行时执行数学或逻辑运算。</p><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Go 语言内置的运算符有：</p><ol><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li></ol><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>/</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr></tbody></table><p><strong>注意：</strong> ++（自增）和–（自减）在Go语言中是单独的语句，并不是运算符。</p><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td></tr><tr><td>!=</td><td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&gt;=</td><td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td></tr><tr><td>&lt;=</td><td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td></tr><tr><td></td><td></td></tr><tr><td>!</td><td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td></tr></tbody></table><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符对整数在内存中的二进制位进行操作。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>参与运算的两数各对应的二进位相与。（两位均为1才为1）</td></tr><tr><td></td><td></td></tr><tr><td>^</td><td>参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。（两位不一样则为1）</td></tr><tr><td>&lt;&lt;</td><td>左移n位就是乘以2的n次方。“a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移n位就是除以2的n次方。“a&gt;&gt;b”是把a的各二进位全部右移b位。</td></tr></tbody></table><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型 【GO语言基础】</title>
      <link href="2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2020/03/24/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p><hr><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64</p><p>其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint8</td><td>无符号 8位整型 (0 到 255)</td></tr><tr><td>uint16</td><td>无符号 16位整型 (0 到 65535)</td></tr><tr><td>uint32</td><td>无符号 32位整型 (0 到 4294967295)</td></tr><tr><td>uint64</td><td>无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td>int8</td><td>有符号 8位整型 (-128 到 127)</td></tr><tr><td>int16</td><td>有符号 16位整型 (-32768 到 32767)</td></tr><tr><td>int32</td><td>有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td>int64</td><td>有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h4 id="特殊整型"><a href="#特殊整型" class="headerlink" title="特殊整型"></a>特殊整型</h4><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint</td><td>32位操作系统上就是uint32，64位操作系统上就是uint64</td></tr><tr><td>int</td><td>32位操作系统上就是int32，64位操作系统上就是int64</td></tr><tr><td>uintptr</td><td>无符号整型，用于存放一个指针</td></tr><tr><td><strong>注意:</strong> 在使用int和 uint类型时，不能假定它是32位或64位的整型，而是考虑int和uint可能在不同平台上的差异。</td><td></td></tr></tbody></table><p><strong>注意事项</strong> 获取对象的长度的内建len()函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用int来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和 uint。</p><h4 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h4><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p><p>v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。 v := 0o377，代表八进制的 377，相当于十进制的 255。 v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。 而且还允许我们用 _ 来分隔数字，比如说：</p><p>v := 123_456 等于 123456。</p><p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">&#x2F;&#x2F; 十进制</span><br><span class="line">var a int &#x3D; 10</span><br><span class="line">fmt.Printf(&quot;%d \n&quot;, a)  &#x2F;&#x2F; 10</span><br><span class="line">fmt.Printf(&quot;%b \n&quot;, a)  &#x2F;&#x2F; 1010  占位符%b表示二进制</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 八进制  以0开头</span><br><span class="line">var b int &#x3D; 077</span><br><span class="line">fmt.Printf(&quot;%o \n&quot;, b)  &#x2F;&#x2F; 77</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 十六进制  以0x开头</span><br><span class="line">var c int &#x3D; 0xff</span><br><span class="line">fmt.Printf(&quot;%x \n&quot;, c)  &#x2F;&#x2F; ff</span><br><span class="line">fmt.Printf(&quot;%X \n&quot;, c)  &#x2F;&#x2F; FF</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。</p><p>打印浮点数时，可以使用fmt包配合动词%f，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">        &quot;fmt&quot;</span><br><span class="line">        &quot;math&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">        fmt.Printf(&quot;%f\n&quot;, math.Pi)</span><br><span class="line">        fmt.Printf(&quot;%.2f\n&quot;, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>complex64和complex128</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var c1 complex64</span><br><span class="line">c1 &#x3D; 1 + 2i</span><br><span class="line">var c2 complex128</span><br><span class="line">c2 &#x3D; 2 + 3i</span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure><p>复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。</p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。</p><p><strong>注意：</strong></p><ol><li>布尔类型变量的默认值为false。</li><li>Go 语言中不允许将整型强制转换为布尔型.</li><li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li></ol><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(“)中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 :&#x3D; &quot;hello&quot;</span><br><span class="line">s2 :&#x3D; &quot;你好&quot;</span><br></pre></td></tr></table></figure><h4 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h4><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td>\r</td><td>回车符（返回行首）</td></tr><tr><td>\n</td><td>换行符（直接跳到下一行的同列位置）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\‘</td><td>单引号</td></tr><tr><td>\“</td><td>双引号</td></tr><tr><td>\\</td><td>反斜杠</td></tr><tr><td>举个例子，我们要打印一个Windows平台下的一个文件路径：</td><td></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;str :&#x3D; \&quot;c:\\Code\\lesson1\\go.exe\&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h4><p>Go语言中要定义一个多行字符串时，就必须使用反引号字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 :&#x3D; &#96;第一行</span><br><span class="line">第二行</span><br><span class="line">第三行</span><br><span class="line">&#96;</span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure><p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p><h4 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h4><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>len(str)</td><td>求长度</td></tr><tr><td>+或fmt.Sprintf</td><td>拼接字符串</td></tr><tr><td>strings.Split</td><td>分割</td></tr><tr><td>strings.contains</td><td>判断是否包含</td></tr><tr><td>strings.HasPrefix,strings.HasSuffix</td><td>前缀/后缀判断</td></tr><tr><td>strings.Index(),strings.LastIndex()</td><td>子串出现的位置</td></tr><tr><td>strings.Join(a[]string, sep string)</td><td>join操作</td></tr></tbody></table><h4 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h4><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a :&#x3D; &#39;中&#39;</span><br><span class="line">var b :&#x3D; &#39;x&#39;</span><br></pre></td></tr></table></figure><p>Go 语言的字符有以下两种：</p><ol><li>uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。</li><li>rune类型，代表一个 UTF-8字符。<br>当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。</li></ol><p>Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 遍历字符串</span><br><span class="line">func traversalString() &#123;</span><br><span class="line">s :&#x3D; &quot;hello沙河&quot;</span><br><span class="line">for i :&#x3D; 0; i &lt; len(s); i++ &#123; &#x2F;&#x2F;byte</span><br><span class="line">fmt.Printf(&quot;%v(%c) &quot;, s[i], s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">for _, r :&#x3D; range s &#123; &#x2F;&#x2F;rune</span><br><span class="line">fmt.Printf(&quot;%v(%c) &quot;, r, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) </span><br></pre></td></tr></table></figure><p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p><p>字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。</p><h4 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h4><p>要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func changeString() &#123;</span><br><span class="line">s1 :&#x3D; &quot;big&quot;</span><br><span class="line">&#x2F;&#x2F; 强制类型转换</span><br><span class="line">byteS1 :&#x3D; []byte(s1)</span><br><span class="line">byteS1[0] &#x3D; &#39;p&#39;</span><br><span class="line">fmt.Println(string(byteS1))</span><br><span class="line"></span><br><span class="line">s2 :&#x3D; &quot;白萝卜&quot;</span><br><span class="line">runeS2 :&#x3D; []rune(s2)</span><br><span class="line">runeS2[0] &#x3D; &#39;红&#39;</span><br><span class="line">fmt.Println(string(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p><p>强制类型转换的基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure><p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p><p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func sqrtDemo() &#123;</span><br><span class="line">var a, b &#x3D; 3, 4</span><br><span class="line">var c int</span><br><span class="line">&#x2F;&#x2F; math.Sqrt()接收的参数是float64类型，需要强制转换</span><br><span class="line">c &#x3D; int(math.Sqrt(float64(a*a + b*b)))</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言基本数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量和常量 【GO语言基础】</title>
      <link href="2020/03/23/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/"/>
      <url>2020/03/23/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。 Go语言中标识符由字母数字和_(下划线）组成，并且只能以字母和_开头。 举几个例子：abc, _, _123, a123。</p><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p><p>Go语言中有25个关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break        default      func         interface    select</span><br><span class="line">case         defer        go           map          struct</span><br><span class="line">chan         else         goto         package      switch</span><br><span class="line">const        fallthrough  if           range        type</span><br><span class="line">continue     for          import       return       var</span><br></pre></td></tr></table></figure><p>此外，Go语言中还有37个保留字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constants:    true  false  iota  nil</span><br><span class="line"></span><br><span class="line">    Types:    int  int8  int16  int32  int64  </span><br><span class="line">              uint  uint8  uint16  uint32  uint64  uintptr</span><br><span class="line">              float32  float64  complex128  complex64</span><br><span class="line">              bool  byte  rune  string  error</span><br><span class="line"></span><br><span class="line">Functions:   make  len  cap  new  append  copy  close  delete</span><br><span class="line">             complex  real  imag</span><br><span class="line">             panic  recover</span><br></pre></td></tr></table></figure><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的来历"><a href="#变量的来历" class="headerlink" title="变量的来历"></a>变量的来历</h4><p>程序运行过程中的数据都是保存在内存中，我们想要在代码中操作某个数据时就需要去内存上找到这个变量，但是如果我们直接在代码中通过内存地址去操作变量的话，代码的可读性会非常差而且还容易出错，所以我们就利用变量将这个数据的内存地址保存起来，以后直接通过这个变量就能找到内存上对应的数据了。</p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。</p><p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。</p><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。 并且Go语言的变量声明后必须使用。</p><h4 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h4><p>Go语言的变量声明格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 变量类型</span><br></pre></td></tr></table></figure><p>变量声明以关键字var开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name string</span><br><span class="line">var age int</span><br><span class="line">var isOk bool</span><br></pre></td></tr></table></figure><h4 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h4><p>每声明一个变量就需要写var关键字会比较繁琐，go语言中还支持批量变量声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    a string</span><br><span class="line">    b int</span><br><span class="line">    c bool</span><br><span class="line">    d float32</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h4><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。</p><p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 类型 &#x3D; 表达式</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name string &#x3D; &quot;Q1mi&quot;</span><br><span class="line">var age int &#x3D; 18</span><br></pre></td></tr></table></figure><p>或者一次初始化多个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name, age &#x3D; &quot;Q1mi&quot;, 20</span><br></pre></td></tr></table></figure><h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;Q1mi&quot;</span><br><span class="line">var age &#x3D; 18</span><br></pre></td></tr></table></figure><h4 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h4><p>在函数内部，可以使用更简略的 := 方式声明并初始化变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; 全局变量m</span><br><span class="line">var m &#x3D; 100</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">n :&#x3D; 10</span><br><span class="line">m :&#x3D; 200 &#x2F;&#x2F; 此处声明局部变量m</span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h4><p>在使用多重赋值时，如果想要忽略某个值，可以使用匿名变量（anonymous variable）。 匿名变量用一个下划线_表示，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func foo() (int, string) &#123;</span><br><span class="line">return 10, &quot;Q1mi&quot;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">x, _ :&#x3D; foo()</span><br><span class="line">_, y :&#x3D; foo()</span><br><span class="line">fmt.Println(&quot;x&#x3D;&quot;, x)</span><br><span class="line">fmt.Println(&quot;y&#x3D;&quot;, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (在Lua等编程语言里，匿名变量也被叫做哑元变量。)</p><p>注意事项：</p><ol><li>函数外的每个语句都必须以关键字开始（var、const、func等）</li><li>:=不能使用在函数外。</li><li>_多用于占位，表示忽略值。</li></ol><hr><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const pi &#x3D; 3.1415</span><br><span class="line">const e &#x3D; 2.7182</span><br></pre></td></tr></table></figure><p>声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p><p>多个常量也可以一起声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    pi &#x3D; 3.1415</span><br><span class="line">    e &#x3D; 2.7182</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    n1 &#x3D; 100</span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面示例中，常量n1、n2、n3的值都是100。</p><h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p>iota是go语言的常量计数器，只能在常量的表达式中使用。</p><p>iota在const关键字出现时将被重置为0。const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">n1 &#x3D; iota &#x2F;&#x2F;0</span><br><span class="line">n2        &#x2F;&#x2F;1</span><br><span class="line">n3        &#x2F;&#x2F;2</span><br><span class="line">n4        &#x2F;&#x2F;3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="几个常见的iota示例"><a href="#几个常见的iota示例" class="headerlink" title="几个常见的iota示例:"></a>几个常见的iota示例:</h4><p>使用_跳过某些值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">n1 &#x3D; iota &#x2F;&#x2F;0</span><br><span class="line">n2        &#x2F;&#x2F;1</span><br><span class="line">_</span><br><span class="line">n4        &#x2F;&#x2F;3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota声明中间插队</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">n1 &#x3D; iota &#x2F;&#x2F;0</span><br><span class="line">n2 &#x3D; 100  &#x2F;&#x2F;100</span><br><span class="line">n3 &#x3D; iota &#x2F;&#x2F;2</span><br><span class="line">n4        &#x2F;&#x2F;3</span><br><span class="line">)</span><br><span class="line">const n5 &#x3D; iota &#x2F;&#x2F;0</span><br></pre></td></tr></table></figure><p>定义数量级 （这里的&lt;&lt;表示左移操作，1&lt;&lt;10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2&lt;&lt;2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">_  &#x3D; iota</span><br><span class="line">KB &#x3D; 1 &lt;&lt; (10 * iota)</span><br><span class="line">MB &#x3D; 1 &lt;&lt; (10 * iota)</span><br><span class="line">GB &#x3D; 1 &lt;&lt; (10 * iota)</span><br><span class="line">TB &#x3D; 1 &lt;&lt; (10 * iota)</span><br><span class="line">PB &#x3D; 1 &lt;&lt; (10 * iota)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>多个iota定义在一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">a, b &#x3D; iota + 1, iota + 2 &#x2F;&#x2F;1,2</span><br><span class="line">c, d                      &#x2F;&#x2F;2,3</span><br><span class="line">e, f                      &#x2F;&#x2F;3,4</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GOLANG </tag>
            
            <tag> GO语言基础 </tag>
            
            <tag> GO语言变量和常量 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
